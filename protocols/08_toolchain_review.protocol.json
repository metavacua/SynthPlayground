{
  "protocol_id": "toolchain-review-on-schema-change-001",
  "description": "A meta-protocol to ensure the agent's toolchain remains synchronized with the architecture of its governing protocols.\n\n*Documentation Warning: Tool `tooling/protocol_auditor.py` not found.*\n\n*Documentation Warning: Tool `tooling/protocol_auditor.py` not found.*\n\n**Associated Tool Documentation (`tooling/protocol_compiler.py`):**\n\n  \n  ### `/app/tooling/protocol_compiler.py`\n  Compiles source protocol files into unified, human-readable and machine-readable artifacts.\n  \n  This script is the engine behind the \"protocol as code\" principle. It discovers,\n  validates, and assembles protocol definitions from a source directory (e.g., `protocols/`)\n  into high-level documents like `AGENTS.md`.\n  \n  Key Functions:\n  - **Discovery:** Scans a directory for source files, including `.protocol.json`\n    (machine-readable rules) and `.protocol.md` (human-readable context).\n  - **Validation:** Uses a JSON schema (`protocol.schema.json`) to validate every\n    `.protocol.json` file, ensuring all protocol definitions are syntactically\n    correct and adhere to the established structure.\n  - **Compilation:** Combines the human-readable markdown and the machine-readable\n    JSON into a single, cohesive Markdown file, embedding the JSON in code blocks.\n  - **Documentation Injection:** Can inject other generated documents, like the\n    `SYSTEM_DOCUMENTATION.md`, into the final output at specified locations.\n  - **Knowledge Graph Generation:** Optionally, it can process the validated JSON\n    protocols and serialize them into an RDF knowledge graph (in Turtle format),\n    creating a machine-queryable version of the agent's governing rules.\n  \n  This process ensures that `AGENTS.md` and other protocol documents are not edited\n  manually but are instead generated from a validated, single source of truth,\n  making the agent's protocols robust, verifiable, and maintainable.\n  \n  **Public Functions:**\n  \n  - #### `def compile_protocols(source_dir, target_file, schema_file, knowledge_graph_file=None, autodoc_file=None)`\n    > Reads all .protocol.json and corresponding .protocol.md files from the\n    > source directory, validates them, and compiles them into a target markdown file.\n    > Optionally, it can also generate a machine-readable knowledge graph.\n  \n  - #### `def install_dependencies()`\n    > Checks for required packages from requirements.txt and installs them if missing.\n  \n  - #### `def load_schema(schema_file)`\n    > Loads the protocol JSON schema.\n  \n  - #### `def main_cli()`\n    > Main function to run the compiler from the command line.\n  \n  - #### `def sanitize_markdown(content)`\n    > Sanitizes markdown content to remove potentially malicious instructions.\n    > This function removes script tags and other potentially malicious HTML/JS.\n\n\n**Associated Tool Documentation (`tooling/hierarchical_compiler.py`):**\n\n  \n  ### `/app/tooling/hierarchical_compiler.py`\n  A hierarchical build system for compiling nested protocol modules.\n  \n  This script orchestrates the compilation of `AGENTS.md` and `README.md` files\n  across a repository with a nested or hierarchical module structure. It is a key\n  component of the system's ability to manage complexity by allowing protocols to\n  be defined in a modular, distributed way while still being presented as a unified,\n  coherent whole at each level of the hierarchy.\n  \n  The compiler operates in two main passes:\n  \n  **Pass 1: Documentation Compilation (Bottom-Up)**\n  1.  **Discovery:** It finds all `protocols` directories in the repository, which\n      signify the root of a documentation module.\n  2.  **Bottom-Up Traversal:** It processes these directories from the most deeply\n      nested ones upwards. This ensures that child modules are always built before\n      their parents.\n  3.  **Child Summary Injection:** For each compiled child module, it generates a\n      summary of its protocols and injects this summary into the parent's\n      `protocols` directory as a temporary file.\n  4.  **Parent Compilation:** When the parent module is compiled, the standard\n      `protocol_compiler.py` automatically includes the injected child summaries,\n      creating a single `AGENTS.md` file that contains both the parent's native\n      protocols and the full protocols of all its direct children.\n  5.  **README Generation:** After each `AGENTS.md` is compiled, the corresponding\n      `README.md` is generated.\n  \n  **Pass 2: Centralized Knowledge Graph Compilation**\n  1.  After all documentation is built, it performs a full repository scan to find\n      every `*.protocol.json` file.\n  2.  It parses all of these files and compiles them into a single, centralized\n      RDF knowledge graph (`protocols.ttl`). This provides a unified,\n      machine-readable view of every protocol defined anywhere in the system.\n  \n  This hierarchical approach allows for both localized, context-specific protocol\n  definitions and a holistic, system-wide understanding of the agent's governing rules.\n  \n  **Public Functions:**\n  \n  - #### `def cleanup_summaries(directory)`\n    > Removes temporary summary files from a protocols directory.\n  \n  - #### `def compile_centralized_knowledge_graph()`\n    > Finds all protocol.json files in the entire repository, loads them, and\n    > compiles them into a single, unified knowledge graph.\n  \n  - #### `def enrich_protocol_descriptions(source_dir)`\n    > Finds protocol.json files, checks for associated tools,\n    > and injects their documentation into the description.\n  \n  - #### `def find_protocol_dirs(root_dir)`\n    > Finds all directories named 'protocols' within the root directory,\n    > ignoring any special-cased directories.\n  \n  - #### `def generate_summary(child_agents_md_path)`\n    > Extracts the full, rendered protocol blocks from a child AGENTS.md file.\n    > This function finds all protocol definitions (human-readable markdown and\n    > the associated machine-readable JSON block) and concatenates them into a\n    > single string to be injected into the parent AGENTS.md.\n  \n  - #### `def get_parent_module(module_path, all_module_paths)`\n    > Finds the direct parent module of a given module.\n  \n  - #### `def get_tool_documentation(tool_path)`\n    > Uses the doc_builder to extract documentation for a specific tool.\n  \n  - #### `def main()`\n    > Main function to orchestrate the hierarchical compilation.\n  \n  - #### `def run_compiler(source_dir)`\n    > Invokes the protocol_compiler.py script as a library.\n  \n  - #### `def run_readme_generator(source_agents_md)`\n    > Invokes the doc_builder.py script to generate a README.\n",
  "rules": [
    {
      "rule_id": "toolchain-audit-on-schema-change",
      "description": "If a change is made to the core protocol schema (`protocol.schema.json`) or to the compilers that process it (`protocol_compiler.py`, `hierarchical_compiler.py`), a formal audit of the entire `tooling/` directory MUST be performed as a subsequent step. This audit should verify that all tools are compatible with the new protocol structure.",
      "enforcement": "This is a procedural rule for any agent developing the protocol system. Adherence can be partially checked by post-commit hooks or review processes that look for a tooling audit in any change that modifies the specified core files."
    }
  ],
  "associated_tools": [
    "tooling/protocol_auditor.py",
    "tooling/protocol_compiler.py",
    "tooling/hierarchical_compiler.py"
  ]
}