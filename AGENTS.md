# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# All changes to agent protocols must be made in the source files
# located in the `protocols/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable JSON definitions embedded.
# ---


# Protocol: Agent Bootstrap

**Rule `bootstrap-load-agents-md`**: On task start, the agent must read and parse `AGENTS.md` from the repository root before formulating a plan. This is the first and highest-priority action.

**Rule `bootstrap-scan-for-documents`**: After processing `AGENTS.md`, the agent should perform a scan of the repository for document files that could contain relevant information. The agent will incorporate the summarized information into its understanding of the project and use it to inform the planning process.

---

# Protocol: Dependency Management

This protocol establishes a formal process for managing Python dependencies to ensure a reliable and repeatable execution environment.

**Rule `dependency-install-on-start`**: After reading `AGENTS.md`, the agent must install the dependencies listed in `requirements.txt` using `pip`. This transforms dependency management from an ad-hoc, reactive process into a proactive, automated, and verifiable step in the agent's workflow.

---

# Protocol: Agent Shell Entry Point

This protocol establishes `tooling/agent_shell.py` as the sole, official entry point for initiating any and all agent tasks.

**Rule `shell-is-primary-entry-point`**: All agent tasks must be initiated through the `agent_shell.py` script. This ensures that every task begins within a controlled, programmatic environment where the MasterControlGraph FSM is correctly instantiated, the centralized logger is initialized, and the agent's lifecycle is managed programmatically.

---

# Meta-Protocol: Toolchain Review on Schema Change

This protocol establishes a critical feedback loop to ensure the agent's toolchain remains synchronized with the architecture of its governing protocols.

**Rule `toolchain-audit-on-schema-change`**: If a change is made to the core protocol schema (`protocol.schema.json`) or to the compilers that process it (`protocol_compiler.py`, `hierarchical_compiler.py`), a formal audit of the entire `tooling/` directory **must** be performed as a subsequent step. This ensures that any modification to the fundamental way protocols are defined or processed is immediately followed by a conscious verification that all dependent tools are still functioning correctly.

---

# --- Child Module: `compliance` ---

# Protocol: AGENTS.md Non-Compliance

This protocol defines non-compliance with `AGENTS.md` protocols and outlines corrective actions.

## Rule `non-compliance-definition`: Definition of Non-Compliance

Non-compliance is violating the rules, conventions, or procedures in `AGENTS.md` and its source protocols.

## Rule `non-compliance-direct-editing`: Prohibition of Direct Artifact Editing

**Violation:** Directly editing any documented build artifact (e.g., `AGENTS.md`).
**Corrective Action:** Revert direct edits. Changes must be made to source files, and the appropriate build command must be executed.

## Rule `non-compliance-test-procedure`: Adherence to Testing Protocols

**Violation:** Failing to execute testing procedures as defined in `AGENTS.md` before submitting changes.
**Corrective Action:** Halt and run the required tests. If tests fail, debug and resolve failures before proceeding.

## Rule `non-compliance-architectural-deviation`: Adherence to Architectural and Convention Guidelines

**Violation:** Introducing changes that contradict the documented architecture, conventions, or file structures.
**Corrective Action:** Identify the deviation, revert the incorrect changes, and re-implement them correctly.

## Rule `non-compliance-self-awareness-failure`: Failure to Maintain Protocol Awareness

**Violation:** Operating with an outdated understanding of the protocols by failing to re-compile `AGENTS.md` when necessary.
**Corrective Action:** Trigger the `make AGENTS.md` command to refresh internal state and re-evaluate the plan.

## Consequence of Non-Compliance

Upon detecting non-compliance, the agent must:
1.  **Halt:** Stop the current execution.
2.  **Report:** Log the violation.
3.  **Correct:** Initiate the defined corrective action or revert and re-plan.

---

# Protocol: Pre-Commit Verification

This protocol establishes the mandatory verification steps before any code is submitted.

## Rule: Mandatory Pre-Commit Checks

Before submitting, the agent **must** execute the `pre_commit_instructions` tool, which provides the checklist for validation, including running tests, requesting code review, and recording learnings. This is a non-optional, fundamental step.

---

# Protocol: `reset_all` Prohibition

**ID:** `reset-all-prohibition-001`

This protocol establishes a strict and unconditional prohibition on the use of the `reset_all` tool, a legacy, high-risk command. The `reset_all` tool has caused multiple catastrophic failures and is too destructive for a production environment.

### Rule `no-reset-all`

-   **Description:** The `reset_all` tool is strictly forbidden under all circumstances.
-   **Enforcement:** The `master_control.py` orchestrator will programmatically block any attempt to call `reset_all` and will immediately terminate the task with a critical error. This is a hard-coded system constraint.

---

---

# --- Child Module: `core` ---

# Protocol: The Context-Free Development Cycle (CFDC)

This protocol introduces a hierarchical planning model. It upgrades the execution model from a Finite State Machine (FSM) to a Pushdown Automaton by introducing a plan execution stack.

The `call_plan` directive allows one plan to execute another as a sub-routine. To ensure the system is guaranteed to halt, the CFDC enforces a `MAX_RECURSION_DEPTH`.

---

# Protocol: The Plan Registry

This protocol introduces a Plan Registry (`knowledge_core/plan_registry.json`) to create a more robust and discoverable system for hierarchical plans. It maps logical plan names to their file paths, decoupling the call from the physical location. The `call_plan` directive uses a registry-first lookup, falling back to a direct path if the name is not found. A `tooling/plan_manager.py` tool is provided for management.

---

# Protocol: The Closed-Loop Self-Correction Cycle

This protocol describes the automated workflow that enables the agent to programmatically improve its own governing protocols based on new knowledge, transforming learning into a machine-driven feedback loop. It uses structured lessons in `knowledge_core/lessons.jsonl` and a `tooling/protocol_updater.py` to enact these improvements, orchestrated by `tooling/self_correction_orchestrator.py`.

---

# Protocol: Deep Research Cycle

This protocol defines a standardized, multi-step plan for conducting in-depth research, ensuring a systematic and thorough investigation. The cycle includes reviewing scanned documents, generating keywords, broad information gathering, targeted information extraction, and synthesis.

---

# Protocol: The Formal Research Cycle (L4)

This protocol establishes the L4 Deep Research Cycle, a specialized, self-contained Finite Development Cycle (FDC) for comprehensive knowledge acquisition. It uses a specialized FSM (`tooling/research_fsm.json`) and executable plans generated by `tooling/research_planner.py` to provide a robust and verifiable mechanism for the agent to explore complex topics.

---

---

# --- Child Module: `critic` ---

# Protocol: Critic `reset_all` Prohibition

This protocol establishes a critical safeguard to protect the integrity of the development workflow.

## Rule: `critic-no-reset`

The agent assigned the role of 'Code Review Critic' is explicitly and strictly forbidden from using the `reset_all` tool.

**Rationale:** The `reset_all` tool is a destructive action that reverts all changes in the workspace. Its use by a review agent could lead to the accidental deletion of work-in-progress. This protocol ensures that the critic's function is limited to analysis and feedback. This prohibition is non-negotiable.

**Enforcement Mechanism:** This protocol is enforced by an external orchestration system that consumes the compiled `AGENTS.md` file.

---

---

# Protocol: The Context-Sensitive Development Cycle (CSDC)

This protocol introduces a development cycle that is sensitive to the logical context in which it operates, incorporating constraints based on principles of logic and computability. It defines two mutually exclusive development models (A and B) that trade off expressive power against the risk of self-referential paradoxes. The `tooling/csdc_cli.py` tool validates plans against a specified model and complexity class (P or EXP).

## Model A: The Introspective Model
- **Permits:** `define_set_of_names`
- **Forbids:** `define_diagonalization_function`

## Model B: The Self-Referential Model
- **Permits:** `define_diagonalization_function`
- **Forbids:** `define_set_of_names`

---

# Protocol: pLLLU Execution

This protocol establishes `tooling/plllu_runner.py` as the official entry point for executing pLLLU (`.plllu`) files.

**Rule `plllu-runner-is-entry-point`**: All pLLLU files must be executed through the `plllu_runner.py` script to ensure they are run in a controlled, programmatic environment.

---

# Security Protocol

This document outlines the security policies and procedures for this project. It includes guidelines for handling sensitive data, reporting vulnerabilities, and maintaining a secure development environment. All contributors are expected to adhere to these protocols to ensure the integrity and safety of the project.

---

# Protocol: Speculative Execution

This protocol empowers the agent to engage in creative and exploratory tasks when it is idle. It provides a formal framework for the agent to generate novel ideas, plans, or artifacts that are not direct responses to a user request, but are instead products of its own analysis of the repository.

## Rules

- **`idle-state-trigger`**: Speculative Execution can only be invoked when the agent has no active, user-assigned task.
- **`formal-proposal-required`**: The first action in any speculative task must be the creation of a formal proposal document outlining the objective, rationale, and plan.
- **`resource-constraints`**: All speculative tasks must operate under predefined resource constraints.
- **`user-review-gate`**: The final output of a speculative task cannot be integrated directly and must be presented to the user for formal review and approval.
- **`speculative-logging`**: All logs, artifacts, and actions generated during a speculative task must be clearly tagged with a `speculative` flag.

---

```json
{
  "protocol_id": "agent-bootstrap-001",
  "description": "Dictates the agent's initial actions upon starting any task.",
  "rules": [
    {
      "rule_id": "bootstrap-load-agents-md",
      "description": "First action: locate, read, and parse AGENTS.md.",
      "enforcement": "Enforced by core startup logic."
    }
  ],
  "associated_tools": [
    "read_file"
  ]
}
```


---

```json
{
  "protocol_id": "dependency-management-001",
  "description": "Ensures a reliable execution environment through formal dependency management.",
  "rules": [
    {
      "rule_id": "dependency-install-on-start",
      "description": "After loading AGENTS.md, the agent MUST install all required Python packages listed in `requirements.txt`.",
      "enforcement": "The agent's core startup logic should execute `pip install -r requirements.txt`."
    }
  ],
  "associated_tools": [
    "run_in_bash_session"
  ]
}
```


---

```json
{
  "protocol_id": "agent-shell-001",
  "description": "Governs the use of the interactive agent shell as the primary entry point for all tasks.",
  "rules": [
    {
      "rule_id": "shell-is-primary-entry-point",
      "description": "All agent tasks must be initiated through the `agent_shell.py` script to ensure proper initialization.",
      "enforcement": "Procedural rule. The agent's operational framework should only expose `agent_shell.py` as the means of starting a new task."
    }
  ],
  "associated_tools": [
    "tooling/agent_shell.py"
  ]
}
```


---

```json
{
  "protocol_id": "toolchain-review-on-schema-change-001",
  "description": "A meta-protocol to ensure the agent's toolchain remains synchronized with its governing protocols.",
  "rules": [
    {
      "rule_id": "toolchain-audit-on-schema-change",
      "description": "If a change is made to the core protocol schema or its compilers, a formal audit of the `tooling/` directory MUST be performed.",
      "enforcement": "Procedural rule for any agent developing the protocol system. Adherence can be partially checked by post-commit hooks or review processes."
    }
  ],
  "associated_tools": [
    "tooling/protocol_auditor.py",
    "tooling/protocol_compiler.py",
    "tooling/hierarchical_compiler.py"
  ]
}
```


---

```json
{
  "protocol_id": "unified-auditor-001",
  "description": "A protocol for the unified repository auditing tool, which combines multiple health and compliance checks into a single interface.",
  "rules": [
    {
      "rule_id": "run-all-audits",
      "description": "The `auditor.py` script should be used to run comprehensive checks on the repository's health. It can be run with 'all' to check protocols, plans, and documentation completeness.",
      "enforcement": "The tool is invoked via the command line, typically through the `make audit` target."
    }
  ],
  "associated_tools": [
    "tooling/auditor.py"
  ]
}
```


---

```json
{
  "protocol_id": "aura-execution-001",
  "description": "A protocol for executing Aura scripts, enabling a more expressive and powerful planning and automation language for the agent.",
  "rules": [
    {
      "rule_id": "execute-aura-script",
      "description": "The `aura_executor.py` tool should be used to execute .aura script files. This tool provides the bridge between the agent's master control loop and the Aura language interpreter.",
      "enforcement": "The tool is used by invoking it from the command line with the path to the Aura script as an argument."
    }
  ],
  "associated_tools": [
    "tooling/aura_executor.py"
  ]
}
```


---

```json
{
  "protocol_id": "capability-verification-001",
  "description": "A protocol for using the capability verifier tool to empirically test the agent's monotonic improvement.",
  "rules": [
    {
      "rule_id": "verify-capability-acquisition",
      "description": "The `capability_verifier.py` tool should be used to test the agent's ability to acquire a new capability defined by a failing test file. The tool orchestrates the failure, self-correction, and verification process.",
      "enforcement": "The tool is used by invoking it from the command line with the path to the target test file."
    }
  ],
  "associated_tools": [
    "tooling/capability_verifier.py"
  ]
}
```


---

```json
{
  "protocol_id": "csdc-001",
  "description": "A protocol for the Context-Sensitive Development Cycle (CSDC), which introduces development models based on logical constraints.",
  "rules": [
    {
      "rule_id": "use-csdc-cli",
      "description": "The `csdc_cli.py` tool must be used to validate plans under the CSDC, enforcing model-specific (A or B) and complexity (P or EXP) constraints.",
      "enforcement": "The tool is used by invoking it from the command line."
    },
    {
      "rule_id": "model-a-constraints",
      "description": "Model A permits `define_set_of_names` but forbids `define_diagonalization_function`.",
      "enforcement": "Enforced by the `fsm_model_a.json` FSM used by the `csdc_cli.py` tool."
    },
    {
      "rule_id": "model-b-constraints",
      "description": "Model B permits `define_diagonalization_function` but forbids `define_set_of_names`.",
      "enforcement": "Enforced by the `fsm_model_b.json` FSM used by the `csdc_cli.py` tool."
    }
  ],
  "associated_tools": [
    "tooling/csdc_cli.py"
  ]
}
```


---

```json
{
  "protocol_id": "unified-doc-builder-001",
  "description": "A protocol for the unified documentation builder, which generates various documentation artifacts from the repository's sources of truth.",
  "rules": [
    {
      "rule_id": "use-doc-builder-for-all-docs",
      "description": "The `doc_builder.py` script is the single entry point for generating all user-facing documentation, including system-level docs, README files, and GitHub Pages. It should be called with the appropriate '--format' argument.",
      "enforcement": "The tool is invoked via the command line, typically through the `make docs`, `make readme`, or `make pages` targets."
    }
  ],
  "associated_tools": [
    "tooling/doc_builder.py"
  ]
}
```


---

```json
{
  "protocol_id": "file-indexing-001",
  "description": "A protocol for maintaining an up-to-date file index to accelerate tool performance.",
  "rules": [
    {
      "rule_id": "update-index-before-submit",
      "description": "Before submitting any changes that alter the file structure (create, delete, rename), the agent MUST rebuild the repository's file index. This ensures that tools relying on the index, such as the FDC validator, have an accurate view of the filesystem.",
      "enforcement": "This is a procedural rule. The agent's pre-submission checklist should include a step to run 'python tooling/file_indexer.py build'."
    }
  ],
  "associated_tools": [
    "tooling/file_indexer.py"
  ]
}
```


---

```json
{
  "protocol_id": "hdl-proving-001",
  "description": "A protocol for interacting with the Hypersequent-calculus-based logic engine, allowing the agent to perform formal logical proofs.",
  "rules": [
    {
      "rule_id": "prove-sequent",
      "description": "The `hdl_prover.py` tool should be used to check the provability of a logical sequent. This tool acts as a wrapper for the underlying Lisp-based prover.",
      "enforcement": "The tool is used by invoking it from the command line with the sequent to be proved as an argument."
    }
  ],
  "associated_tools": [
    "tooling/hdl_prover.py"
  ]
}
```


---

```json
{
  "protocol_id": "agent-interaction-001",
  "description": "A protocol governing the agent's core interaction and planning tools.",
  "rules": [
    {
      "rule_id": "planning-tool-access",
      "description": "The agent is authorized to use the `set_plan` tool to create and update its execution plan. This is a foundational capability for task execution.",
      "enforcement": "The agent's core logic should be designed to use this tool for all planning activities."
    },
    {
      "rule_id": "communication-tool-access",
      "description": "The agent is authorized to use the `message_user` tool to communicate with the user, providing updates and asking for clarification. This is essential for a collaborative workflow.",
      "enforcement": "The agent's core logic should be designed to use this tool for all user-facing communication."
    }
  ],
  "associated_tools": [
    "set_plan",
    "message_user"
  ]
}
```


---

```json
{
  "protocol_id": "plllu-execution-001",
  "description": "A protocol for executing pLLLU scripts.",
  "rules": [
    {
      "rule_id": "execute-plllu-script",
      "description": "The `plllu_runner.py` tool should be used to execute .plllu script files.",
      "enforcement": "The tool is used by invoking it from the command line with the path to the pLLLU script."
    }
  ],
  "associated_tools": [
    "tooling/plllu_runner.py"
  ]
}
```


---

```json
{
  "protocol_id": "security-header",
  "description": "Defines the identity and purpose of the Security Protocol document.",
  "rules": []
}
```


---

```json
{
  "protocol_id": "security-vuln-reporting-001",
  "description": "Defines the official policy and procedure for reporting security vulnerabilities.",
  "rules": [
    {
      "rule_id": "vuln-reporting-channel",
      "description": "All suspected security vulnerabilities MUST be reported privately to the designated security contact.",
      "enforcement": "This is a procedural rule. The designated contact is specified in the project's main SECURITY.md file."
    },
    {
      "rule_id": "no-public-disclosure",
      "description": "Vulnerabilities MUST NOT be disclosed publicly until a patch is available and has been distributed.",
      "enforcement": "Violation of this rule may result in being banned from the project community."
    }
  ]
}
```


---

```json
{
  "protocol_id": "speculative-execution-001",
  "description": "Governs the agent's ability to initiate and execute self-generated, exploratory tasks during idle periods.",
  "rules": [
    {
      "rule_id": "idle-state-trigger",
      "description": "The agent may only initiate a speculative task when idle.",
      "enforcement": "The agent's main control loop must verify an idle state before allowing invocation of a speculative plan."
    },
    {
      "rule_id": "formal-proposal-required",
      "description": "A speculative task must begin with a formal proposal document.",
      "enforcement": "The initial plan for any speculative task must include a step to generate and save a proposal artifact."
    },
    {
      "rule_id": "resource-constraints",
      "description": "Speculative tasks must operate under defined resource limits.",
      "enforcement": "A system-level constraint that the agent orchestrator must enforce."
    },
    {
      "rule_id": "user-review-gate",
      "description": "Final artifacts from a speculative task must be submitted for user review.",
      "enforcement": "The agent is forbidden from using 'submit' or 'merge' in a speculative context and must use 'request_user_input'."
    },
    {
      "rule_id": "speculative-logging",
      "description": "All logs and artifacts from a speculative task must be tagged as 'speculative'.",
      "enforcement": "Logging and file-creation tools should be context-aware and apply this tag in speculative mode."
    }
  ],
  "associated_tools": [
    "set_plan",
    "create_file_with_block",
    "request_user_input"
  ]
}
```


---
