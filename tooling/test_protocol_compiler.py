import unittest
import os
import json
import shutil
from tooling.protocol_compiler import compile_protocols
import jsonschema


class TestProtocolCompiler(unittest.TestCase):

    def setUp(self):
        self.test_dir = "test_protocol_compiler_dir"
        self.source_dir = os.path.join(self.test_dir, "protocols")
        self.output_dir = os.path.join(self.test_dir, "output")
        self.autodoc_dir = os.path.join(self.test_dir, "docs")

        os.makedirs(self.source_dir, exist_ok=True)
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.autodoc_dir, exist_ok=True)

        # Create a simple schema
        self.schema_path = os.path.join(self.source_dir, "protocol.schema.json")
        with open(self.schema_path, "w") as f:
            json.dump(
                {
                    "type": "object",
                    "properties": {
                        "protocol_id": {"type": "string"},
                        "description": {"type": "string"},
                        "associated_tools": {
                            "type": "array",
                            "items": {"type": "string"},
                        },
                    },
                    "required": ["protocol_id", "description"],
                },
                f,
            )

    def tearDown(self):
        shutil.rmtree(self.test_dir)

    def test_successful_compilation(self):
        """Tests that valid protocols are compiled correctly."""
        # Create valid protocol files
        with open(os.path.join(self.source_dir, "p1.protocol.json"), "w") as f:
            json.dump(
                {
                    "protocol_id": "TEST-001",
                    "description": "First test protocol.",
                    "associated_tools": ["tool_a"],
                },
                f,
            )
        with open(os.path.join(self.source_dir, "p1.protocol.md"), "w") as f:
            f.write("# Protocol 1\nThis is the first protocol.")
        with open(os.path.join(self.source_dir, "p2.protocol.json"), "w") as f:
            json.dump(
                {"protocol_id": "TEST-002", "description": "Second test protocol."}, f
            )

        # Create autodoc files
        autodoc_path = os.path.join(self.autodoc_dir, "SYSTEM_DOCUMENTATION.md")
        with open(autodoc_path, "w") as f:
            f.write("# System Documentation\nThis is the system documentation.")
        with open(
            os.path.join(self.source_dir, "autodoc_placeholder.autodoc.md"), "w"
        ) as f:
            f.write("<!-- AUTODOC PLACEHOLDER -->")

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        compile_protocols(
            source_dir=self.source_dir,
            target_file=target_file,
            schema_file=self.schema_path,
            autodoc_file=autodoc_path,
        )

        self.assertTrue(os.path.exists(target_file))

        with open(target_file, "r") as f:
            content = f.read()

        # Check for disclaimer
        self.assertIn("DO NOT EDIT THIS FILE DIRECTLY", content)
        # Check for autodoc content
        self.assertIn("# System Documentation", content)
        # Check for markdown content
        self.assertIn("# Protocol 1", content)
        # Check for JSON content
        self.assertIn("TEST-001", content)
        self.assertIn("TEST-002", content)

    def test_validation_error(self):
        """Tests that the compiler raises a validation error for invalid JSON."""
        # Create an invalid protocol file
        with open(os.path.join(self.source_dir, "invalid.protocol.json"), "w") as f:
            json.dump({"protocol_id": "INVALID-001"}, f)  # Missing 'description'

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        with self.assertRaises(jsonschema.ValidationError):
            compile_protocols(
                source_dir=self.source_dir,
                target_file=target_file,
                schema_file=self.schema_path,
            )

    def test_knowledge_graph_generation(self):
        """Tests that the knowledge graph is generated when requested."""
        # Create valid protocol files
        with open(os.path.join(self.source_dir, "p1.protocol.json"), "w") as f:
            json.dump(
                {
                    "protocol_id": "TEST-001",
                    "description": "First test protocol.",
                    "associated_tools": ["tool_a"],
                },
                f,
            )
        with open(os.path.join(self.source_dir, "p2.protocol.json"), "w") as f:
            json.dump(
                {"protocol_id": "TEST-002", "description": "Second test protocol."}, f
            )

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        kg_file = os.path.join(self.output_dir, "protocols.ttl")

        # Create a context file needed for RDF generation
        with open(os.path.join(self.source_dir, "protocol.context.jsonld"), "w") as f:
            json.dump({"@context": {"protocol_id": "http://schema.org/identifier"}}, f)

        compile_protocols(
            source_dir=self.source_dir,
            target_file=target_file,
            schema_file=self.schema_path,
            knowledge_graph_file=kg_file,
        )

        self.assertTrue(os.path.exists(kg_file))
        with open(kg_file, "r") as f:
            content = f.read()

        self.assertIn("TEST-001", content)
        self.assertIn("TEST-002", content)

    def test_empty_source_directory(self):
        """Tests that the compiler handles an empty source directory."""
        empty_source_dir = os.path.join(self.test_dir, "empty_protocols")
        os.makedirs(empty_source_dir, exist_ok=True)
        target_file = os.path.join(self.output_dir, "AGENTS.md")

        # We need a schema file, even in an empty dir, as load_schema is called first
        with open(os.path.join(empty_source_dir, "protocol.schema.json"), "w") as f:
            json.dump({}, f)

        compile_protocols(
            source_dir=empty_source_dir,
            target_file=target_file,
            schema_file=os.path.join(empty_source_dir, "protocol.schema.json"),
        )
        # The compiler should not create a file if there are no protocols.
        self.assertFalse(os.path.exists(target_file))

    def test_malformed_json(self):
        """Tests that the compiler raises an error for malformed JSON."""
        with open(os.path.join(self.source_dir, "malformed.protocol.json"), "w") as f:
            f.write(
                "{'invalid_json': True,}"
            )  # Malformed JSON with trailing comma and single quotes

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        with self.assertRaises(json.JSONDecodeError):
            compile_protocols(
                source_dir=self.source_dir,
                target_file=target_file,
                schema_file=self.schema_path,
            )

    def test_missing_schema(self):
        """Tests that the compiler returns None when the schema is missing."""
        target_file = os.path.join(self.output_dir, "AGENTS.md")
        # The function `load_schema` prints an error and returns None, which causes compile_protocols to return early.
        # We can't easily test for the printed output without more complex mocking,
        # but we can check that the output file is not created.
        compile_protocols(
            source_dir=self.source_dir,
            target_file=target_file,
            schema_file="non_existent_schema.json",
        )
        self.assertFalse(os.path.exists(target_file))


if __name__ == "__main__":
    unittest.main()
