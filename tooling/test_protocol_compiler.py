import unittest
import os
import json
import shutil
from tooling.protocol_compiler import compile_protocols, load_schema
import jsonschema

class TestProtocolCompiler(unittest.TestCase):

    def setUp(self):
        self.test_dir = "test_protocol_compiler_dir"
        self.source_dir = os.path.join(self.test_dir, "protocols")
        self.output_dir = os.path.join(self.test_dir, "output")
        self.autodoc_dir = os.path.join(self.test_dir, "docs")

        os.makedirs(self.source_dir, exist_ok=True)
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.autodoc_dir, exist_ok=True)

        # Create a simple schema
        self.schema_path = os.path.join(self.source_dir, "protocol.schema.json")
        with open(self.schema_path, "w") as f:
            json.dump({
                "type": "object",
                "properties": {
                    "protocol_id": {"type": "string"},
                    "description": {"type": "string"},
                    "associated_tools": {"type": "array", "items": {"type": "string"}}
                },
                "required": ["protocol_id", "description"]
            }, f)

    def tearDown(self):
        shutil.rmtree(self.test_dir)

    def test_successful_compilation(self):
        """Tests that valid protocols are compiled correctly with doc injection."""
        # Create valid protocol files
        with open(os.path.join(self.source_dir, "p1.protocol.json"), "w") as f:
            json.dump({"protocol_id": "TEST-001", "description": "First test protocol.", "associated_tools": ["tool_a"]}, f)
        with open(os.path.join(self.source_dir, "p1.protocol.md"), "w") as f:
            f.write("# Protocol 1\nThis is the first protocol.")
        with open(os.path.join(self.source_dir, "p2.protocol.json"), "w") as f:
            json.dump({"protocol_id": "TEST-002", "description": "Second test protocol."}, f)

        # Create doc sources
        system_doc_path = os.path.join(self.autodoc_dir, "SYSTEM_DOCUMENTATION.md")
        with open(system_doc_path, "w") as f:
            f.write("# System Documentation\nThis is the system documentation.")
        readme_path = os.path.join(self.autodoc_dir, "README.md")
        with open(readme_path, "w") as f:
            f.write("# Module Documentation\nThis is the readme.")
        doc_sources = {"system": system_doc_path, "readme": readme_path}

        # Create placeholder files to trigger injection
        with open(os.path.join(self.source_dir, "system.autodoc.md"), "w") as f:
            f.write("<!-- SYSTEM AUTODOC -->")
        with open(os.path.join(self.source_dir, "readme.autodoc.md"), "w") as f:
            f.write("<!-- README AUTODOC -->")

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        compile_protocols(
            source_dir=self.source_dir,
            target_file=target_file,
            schema_file=self.schema_path,
            doc_sources=doc_sources
        )

        self.assertTrue(os.path.exists(target_file))

        with open(target_file, "r") as f:
            content = f.read()

        # Check for disclaimer
        self.assertIn("DO NOT EDIT THIS FILE DIRECTLY", content)
        # Check for injected content
        self.assertIn("# System Documentation", content)
        self.assertIn("# Module Documentation", content)
        # Check for markdown content
        self.assertIn("# Protocol 1", content)
        # Check for JSON content
        self.assertIn("TEST-001", content)
        self.assertIn("TEST-002", content)

    def test_validation_error(self):
        """Tests that the compiler raises a validation error for invalid JSON."""
        # Create an invalid protocol file
        with open(os.path.join(self.source_dir, "invalid.protocol.json"), "w") as f:
            json.dump({"protocol_id": "INVALID-001"}, f) # Missing 'description'

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        with self.assertRaises(jsonschema.ValidationError):
            compile_protocols(
                source_dir=self.source_dir,
                target_file=target_file,
                schema_file=self.schema_path
            )

    def test_knowledge_graph_generation(self):
        """
        Tests that the knowledge graph generation runs without error.
        Note: The final KG file is serialized by the hierarchical compiler,
        so this test just ensures the processing step within compile_protocols works.
        """
        kg_file = os.path.join(self.output_dir, "protocols.ttl")
        try:
            compile_protocols(
                source_dir=self.source_dir,
                target_file=os.path.join(self.output_dir, "AGENTS.md"),
                schema_file=self.schema_path,
                knowledge_graph_file=kg_file
            )
        except Exception as e:
            self.fail(f"KG generation step failed with an exception: {e}")

    def test_empty_source_directory(self):
        """Tests that the compiler handles an empty source directory."""
        empty_source_dir = os.path.join(self.test_dir, "empty_protocols")
        os.makedirs(empty_source_dir, exist_ok=True)
        target_file = os.path.join(self.output_dir, "AGENTS.md")
        empty_schema_path = os.path.join(empty_source_dir, "protocol.schema.json")

        # The new logic requires a schema file. If it's missing, it should fail.
        # This test now checks for the expected ValueError when the schema is not found.
        with self.assertRaises(ValueError):
             compile_protocols(
                source_dir=empty_source_dir,
                target_file=target_file,
                schema_file="non_existent_schema.json" # Force a failure
            )

    def test_malformed_json(self):
        """Tests that the compiler raises an error for malformed JSON."""
        with open(os.path.join(self.source_dir, "malformed.protocol.json"), "w") as f:
            f.write("{'invalid_json': True,}") # Malformed JSON with trailing comma and single quotes

        target_file = os.path.join(self.output_dir, "AGENTS.md")
        with self.assertRaises(json.JSONDecodeError):
            compile_protocols(
                source_dir=self.source_dir,
                target_file=target_file,
                schema_file=self.schema_path
            )

    def test_missing_schema(self):
        """Tests that the compiler raises a ValueError when the schema is missing."""
        target_file = os.path.join(self.output_dir, "AGENTS.md")
        with self.assertRaises(ValueError):
            compile_protocols(
                source_dir=self.source_dir,
                target_file=target_file,
                schema_file="non_existent_schema.json"
            )


if __name__ == "__main__":
    unittest.main()