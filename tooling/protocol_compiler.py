"""
This script serves as the master orchestrator for the hierarchical protocol compilation.
It discovers all protocol modules (subdirectories within `protocols/` that contain a `build.py`),
executes their local build scripts in parallel, and then generates a root `AGENTS.md`
that links to all the compiled modules, creating a unified, navigable system.
"""

import os
import sys
import argparse
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed

# Add the root directory to the Python path to allow importing utils
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.file_system_utils import find_protocol_dirs, get_protocol_dir_name

# --- Configuration ---
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
ROOT_PROTOCOLS_DIR = os.path.join(ROOT_DIR, "protocols")
ROOT_AGENTS_MD = os.path.join(ROOT_DIR, "AGENTS.md")
LOCAL_BUILD_SCRIPT_NAME = "build.py"

def run_local_build(path_to_protocol_dir):
    """
    Executes the local build script for a given protocol module.
    Returns the path and a boolean indicating success.
    """
    local_builder = os.path.join(path_to_protocol_dir, LOCAL_BUILD_SCRIPT_NAME)

    if not os.path.exists(local_builder):
        # This case should ideally not be hit if find_protocol_dirs is accurate.
        print(f"--- Warning: No local builder found in {path_to_protocol_dir}. Skipping. ---", file=sys.stderr)
        return path_to_protocol_dir, False

    try:
        print(f"--- Executing local builder: {local_builder} ---")
        subprocess.check_call([sys.executable, local_builder], cwd=path_to_protocol_dir, stdout=sys.stdout, stderr=sys.stderr)
        return path_to_protocol_dir, True
    except subprocess.CalledProcessError as e:
        print(f"--- Error: Failed to compile protocols in {path_to_protocol_dir}: {e} ---", file=sys.stderr)
        return path_to_protocol_dir, False
    except Exception as e:
        print(f"--- An unexpected error occurred in {path_to_protocol_dir}: {e} ---", file=sys.stderr)
        return path_to_protocol_dir, False


def generate_root_agents_md(child_protocol_dirs):
    """
    Generates the root AGENTS.md file, linking to all successfully compiled child modules.
    """
    print("\n--- Generating Root AGENTS.md ---")
    disclaimer = f"""
# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# It provides a top-level view of the repository's protocol modules.
# All changes to agent protocols must be made in the source files
# located in the `protocols/` subdirectories, each with its own `build.py`.
# ---
"""
    # Include content from any .md files at the root of the protocols dir, if needed.
    # This is determined by the build script in `protocols/` itself.
    # The root AGENTS.md only links to the modules.

    content = [disclaimer]
    content.append("\n\n# --- Protocol Modules ---\n")
    content.append(
        "This repository uses a hierarchical, decentralized protocol system. Each of the following "
        "directories contains a self-contained set of protocols and is compiled by its own local build script."
    )

    # Filter out the root protocol dir itself from the list of children to link
    child_dirs_to_link = sorted([p for p in child_protocol_dirs if p != ROOT_PROTOCOLS_DIR])

    for dir_path in child_dirs_to_link:
        module_name = get_protocol_dir_name(dir_path)
        # All modules now have their own AGENTS.md
        relative_path = os.path.relpath(os.path.join(dir_path, "AGENTS.md"), ROOT_DIR)
        link = f"- [{module_name.capitalize()}]({relative_path})"
        content.append(link)

    # Add a link to the root protocols' AGENTS.md if it exists
    root_protocol_agents_md = os.path.join(ROOT_PROTOCOLS_DIR, "AGENTS.md")
    if os.path.exists(root_protocol_agents_md):
         content.append("\n## Root Protocols\n")
         content.append(f"General protocols are defined in the [root protocol module](./{os.path.relpath(root_protocol_agents_md, ROOT_DIR)}).")


    with open(ROOT_AGENTS_MD, "w") as f:
        f.write("\n".join(content))
    print(f"Successfully generated root AGENTS.md at {ROOT_AGENTS_MD}")


def main_orchestrator():
    """
    Main function to find and run all local build scripts in parallel.
    """
    parser = argparse.ArgumentParser(description="Parallel Protocol Build Orchestrator")
    # Retaining for potential future use, but not currently used by the orchestrator itself.
    parser.add_argument("--knowledge-graph-file", help="Path to output knowledge graph file (currently disabled in decentralized build).")
    args = parser.parse_args()

    print("--- Starting Parallel Protocol Build Orchestration ---")

    # find_protocol_dirs should be adapted to find dirs containing 'build.py'
    all_dirs = find_protocol_dirs(ROOT_PROTOCOLS_DIR)

    build_script_dirs = [d for d in all_dirs if os.path.exists(os.path.join(d, LOCAL_BUILD_SCRIPT_NAME))]

    if not build_script_dirs:
        print("No protocol directories with a 'build.py' script found. Exiting.", file=sys.stderr)
        return

    successful_compilations = []
    failed_compilations = []

    with ThreadPoolExecutor() as executor:
        future_to_dir = {executor.submit(run_local_build, dir_path): dir_path for dir_path in build_script_dirs}
        for future in as_completed(future_to_dir):
            path, success = future.result()
            if success:
                successful_compilations.append(path)
            else:
                failed_compilations.append(path)

    if failed_compilations:
        print("\n--- Compilation Summary: Failures Detected ---")
        for path in failed_compilations:
            print(f"- {get_protocol_dir_name(path)}")
        sys.exit(1)

    print("\n--- All protocol modules compiled successfully. ---")

    generate_root_agents_md(successful_compilations)

    print("\n--- Parallel Protocol Build Orchestration Finished ---")


if __name__ == "__main__":
    main_orchestrator()