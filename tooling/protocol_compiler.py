"""
This script serves as the master orchestrator for the hierarchical protocol compilation.
It discovers all protocol modules (subdirectories within `protocols/` that contain a `build.py`),
executes their local build scripts in parallel, and then generates a root `AGENTS.md`
that links to all the compiled modules, creating a unified, navigable system.
"""

import os
import sys
import argparse
import subprocess
import sys
import re
import time
import importlib.util
import json
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from concurrent.futures import ThreadPoolExecutor, as_completed
from rdflib import Graph, URIRef, Literal, Namespace
from rdflib.namespace import RDF, RDFS

# Add the root directory to the Python path to allow importing utils
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.file_system_utils import find_protocol_dirs, get_protocol_dir_name
from utils.file_system_utils import find_files, find_protocol_dirs, get_protocol_dir_name

# --- Dependency Management ---
def install_dependencies():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    requirements_path = os.path.join(script_dir, "requirements.txt")
    if not os.path.exists(requirements_path):
        return
    try:
        from pip._internal.operations import freeze
    except ImportError:
        freeze = None
    if freeze:
        installed_packages = [line.split('==')[0] for line in freeze.freeze()]
    else:
        req = subprocess.run([sys.executable, '-m', 'pip', 'freeze'], capture_output=True, text=True)
        installed_packages = [line.split('==')[0] for line in req.stdout.split('\n')]
    with open(requirements_path, 'r') as f:
        required_packages = [line.strip() for line in f if line.strip() and not line.startswith('#')]
    missing_packages = [pkg for pkg in required_packages if pkg.lower() not in [p.lower() for p in installed_packages]]
    if missing_packages:
        print(f"Installing missing dependencies: {', '.join(missing_packages)}")
        subprocess.check_call([sys.executable, "-m", "pip", "install", *missing_packages])

install_dependencies()

import jsonschema

# --- Configuration ---
ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
ROOT_PROTOCOLS_DIR = os.path.join(ROOT_DIR, "protocols")
ROOT_AGENTS_MD = os.path.join(ROOT_DIR, "AGENTS.md")
LOCAL_BUILD_SCRIPT_NAME = "build.py"

DISCLAIMER_TEMPLATE = """\
# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# All changes to agent protocols must be made in the source files
# located in the `{source_dir_name}/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable JSON definitions embedded.
# ---
"""

def load_schema(schema_file):
    try:
        with open(schema_file, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: Schema file not found at {schema_file}")
        return None
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from schema file at {schema_file}")
        return None

import ast

def sanitize_markdown(content):
    content = re.sub(r"<script.*?>.*?</script>", "", content, flags=re.IGNORECASE | re.DOTALL)
    content = re.sub(r" on\w+=\".*?\"", "", content, flags=re.IGNORECASE)
    content = re.sub(r"<<<SENSITIVE_INSTRUCTIONS>>>.*<<<SENSITIVE_INSTRUCTIONS>>>", "", content, flags=re.DOTALL)
    return content

def extract_docstring(filepath):
    """Extracts the module-level docstring from a Python file."""
    full_path = os.path.join(ROOT_DIR, filepath)
    if not os.path.exists(full_path):
        return f"_File not found: {filepath}_"
    try:
        with open(full_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=filepath)
        docstring = ast.get_docstring(tree)
        return docstring if docstring else "_No module-level docstring found._"
    except Exception as e:
        return f"_Error parsing file {filepath}: {e}_"

def compile_single_module(source_dir, target_file, schema_file, knowledge_graph=None, autodoc_file=None):
    output_filename = os.path.basename(target_file)
    print(f"--- Starting Protocol Compilation for {output_filename} ---")
    print(f"Source directory: {source_dir}")
    print(f"Target file: {target_file}")

    schema = load_schema(schema_file)
    if not schema:
        return

    autodoc_placeholders = sorted([os.path.join(source_dir, f) for f in find_files("*.autodoc.md", base_dir=source_dir)])
    all_md_files = sorted([os.path.join(source_dir, f) for f in find_files("*.protocol.md", base_dir=source_dir, recursive=False)])
    all_json_files = sorted([os.path.join(source_dir, f) for f in find_files("*.protocol.json", base_dir=source_dir, recursive=False)])

    if not all_md_files and not all_json_files and not autodoc_placeholders:
        with open(target_file, "w") as f:
            f.write(DISCLAIMER_TEMPLATE.format(source_dir_name=os.path.basename(source_dir)))
        return

    disclaimer = DISCLAIMER_TEMPLATE.format(source_dir_name=os.path.basename(source_dir))
    final_content = [disclaimer]

    all_associated_tools = set()

    for file_path in autodoc_placeholders:
        if autodoc_file and os.path.exists(autodoc_file):
            with open(autodoc_file, "r") as f:
                final_content.append(f.read())
        final_content.append("\n---\n")

    for file_path in all_md_files:
        with open(file_path, "r") as f:
            content = f.read()
            sanitized_content = sanitize_markdown(content)
            final_content.append(sanitized_content)
        final_content.append("\n---\n")

    for file_path in all_json_files:
        with open(file_path, "r") as f:
            protocol_data = json.load(f)
        jsonschema.validate(instance=protocol_data, schema=schema)

        if knowledge_graph is not None:
            protocol_data_for_ld = protocol_data.copy()
            context_path = os.path.join(source_dir, "protocol.context.jsonld")
            if os.path.exists(context_path):
                relative_context_path = os.path.relpath(context_path, os.path.dirname(file_path))
                protocol_data_for_ld["@context"] = relative_context_path
                base_uri = "file://" + os.path.abspath(os.path.dirname(file_path)) + "/"
                knowledge_graph.parse(data=json.dumps(protocol_data_for_ld), format="json-ld", publicID=base_uri)
        json_string = json.dumps(protocol_data, indent=2)
        md_json_block = f"```json\n{json_string}\n```\n"
        final_content.append(md_json_block)
        final_content.append("\n---\n")

    if all_associated_tools:
        final_content.append("\n\n# --- Associated Tool Documentation ---\n")
        for tool_path in sorted(list(all_associated_tools)):
            if tool_path.endswith(".py"):
                docstring = extract_docstring(tool_path)
                final_content.append(f"## `{os.path.basename(tool_path)}`\n\n{docstring}\n\n---\n")
            else:
                # Handle built-in or non-script tools
                final_content.append(f"## `{tool_path}`\n\n_This is a built-in or conceptual tool. Documentation is not available via automated extraction._\n\n---\n")

    final_output_string = "\n".join(final_content)
    temp_target_file = target_file + ".tmp"
    os.makedirs(os.path.dirname(target_file), exist_ok=True)
    with open(temp_target_file, "w") as f:
        f.write(final_output_string)
    os.rename(temp_target_file, target_file)

def compile_module_wrapper(path_to_protocol_dir):
    """Wrapper to execute the local build script in a given protocol directory."""
    local_builder = os.path.join(path_to_protocol_dir, LOCAL_BUILD_SCRIPT_NAME)
    if not os.path.exists(local_builder):
        # This is not an error, it just means it's a directory with no build script.
        # It might just contain other protocol modules.
        return path_to_protocol_dir, True # Return True as there was no failure.
    try:
        print(f"--- Executing local builder: {local_builder} ---")
        subprocess.check_call([sys.executable, local_builder], cwd=path_to_protocol_dir, stdout=sys.stdout, stderr=sys.stderr)
        return path_to_protocol_dir, True
    except subprocess.CalledProcessError as e:
        print(f"--- Error: Failed to compile protocols in {path_to_protocol_dir}: {e} ---", file=sys.stderr)
        return path_to_protocol_dir, False
    except Exception as e:
        print(f"--- An unexpected error occurred in {path_to_protocol_dir}: {e} ---", file=sys.stderr)
        return path_to_protocol_dir, False


def generate_root_agents_md(child_protocol_dirs):
    """
    Generates the root AGENTS.md file, linking to all successfully compiled child modules.
    """
    print("\n--- Generating Root AGENTS.md ---")
    disclaimer = f"""
# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# It provides a top-level view of the repository's protocol modules.
# For dynamic, context-aware protocol queries, use the 'protocol_oracle.py' tool.
# All changes to agent protocols must be made in the source files
# located in the `protocols/` subdirectories, each with its own `build.py`.
# ---
"""
    # Include content from any .md files at the root of the protocols dir, if needed.
    # This is determined by the build script in `protocols/` itself.
    # The root AGENTS.md only links to the modules.

    content = [disclaimer]
    content.append("\n\n# --- Protocol Modules ---\n")
    content.append(
        "This repository uses a hierarchical, decentralized protocol system. Each of the following "
        "directories contains a self-contained set of protocols and is compiled by its own local build script."
    )

    # Filter out the root protocol dir itself from the list of children to link
    child_dirs_to_link = sorted([p for p in child_protocol_dirs if p != ROOT_PROTOCOLS_DIR])

    for dir_path in child_dirs_to_link:
        module_name = get_protocol_dir_name(dir_path)
        # All modules now have their own AGENTS.md
        relative_path = os.path.relpath(os.path.join(dir_path, "AGENTS.md"), ROOT_DIR)
        link = f"- [{module_name.capitalize()}]({relative_path})"
        content.append(link)

    # Add a link to the root protocols' AGENTS.md if it exists
    root_protocol_agents_md = os.path.join(ROOT_PROTOCOLS_DIR, "AGENTS.md")
    if os.path.exists(root_protocol_agents_md):
         content.append("\n## Root Protocols\n")
         content.append(f"General protocols are defined in the [root protocol module](./{os.path.relpath(root_protocol_agents_md, ROOT_DIR)}).")


    with open(ROOT_AGENTS_MD, "w") as f:
        f.write("\n".join(content))
    print(f"Successfully generated root AGENTS.md at {ROOT_AGENTS_MD}")


def main_orchestrator():
    """
    Main function to find and run all local build scripts in parallel.
    """
    parser = argparse.ArgumentParser(description="Parallel Protocol Build Orchestrator")
    parser.add_argument("--knowledge-graph-file", help="Path to output knowledge graph file (currently disabled in decentralized build).")
    args = parser.parse_args()

    print("--- Starting Parallel Protocol Build Orchestration ---")
    start_time = time.time()

    all_protocol_dirs = find_protocol_dirs(ROOT_PROTOCOLS_DIR)
    if not all_protocol_dirs:
        print("No protocol directories found. Exiting.")
        return

    successful_compilations = []
    failed_compilations = []

    with ThreadPoolExecutor() as executor:
        future_to_dir = {executor.submit(compile_module_wrapper, dir_path): dir_path for dir_path in all_protocol_dirs}
        for future in as_completed(future_to_dir):
            path, success = future.result()
            if success:
                successful_compilations.append(path)
            else:
                failed_compilations.append(path)

    if failed_compilations:
        print("\n--- Compilation Summary: Failures Detected ---")
        for path in failed_compilations:
            print(f"- {get_protocol_dir_name(path)}")
        sys.exit(1)

    print("\n--- All protocol modules compiled successfully. ---")

    generate_root_agents_md(successful_compilations)

    print("\n--- Parallel Protocol Build Orchestration Finished ---")

    end_time = time.time()
    print(f"\n--- Compilation Finished in {end_time - start_time:.2f} seconds ---")

if __name__ == "__main__":
    main_orchestrator()
