@prefix proto: <https://factory.ai/ns/protocol/> .
@prefix schema: <https://schema.org/> .

<file:///app/compliance/protocols/best-practices-001> proto:associatedTool <file:///app/compliance/protocols/create_file_with_block>,
        <file:///app/compliance/protocols/delete_file>,
        <file:///app/compliance/protocols/grep>,
        <file:///app/compliance/protocols/list_files>,
        <file:///app/compliance/protocols/overwrite_file_with_block>,
        <file:///app/compliance/protocols/read_file>,
        <file:///app/compliance/protocols/replace_with_git_merge_diff> ;
    proto:hasRule <file:///app/compliance/protocols/verify-after-write> ;
    schema:description "A set of best practices derived from observing successful, data-driven workflow patterns." .

<file:///app/compliance/protocols/meta-protocol-001> proto:associatedTool <file:///app/compliance/protocols/run_in_bash_session> ;
    proto:hasRule <file:///app/compliance/protocols/agents-md-self-awareness> ;
    schema:description "A meta-protocol governing the agent's awareness and maintenance of its own core protocol files." .

<file:///app/compliance/protocols/non-compliance-protocol-001> proto:hasRule <file:///app/compliance/protocols/non-compliance-architectural-deviation>,
        <file:///app/compliance/protocols/non-compliance-definition>,
        <file:///app/compliance/protocols/non-compliance-direct-editing>,
        <file:///app/compliance/protocols/non-compliance-self-awareness-failure>,
        <file:///app/compliance/protocols/non-compliance-test-procedure> ;
    schema:description "A protocol that defines non-compliance with AGENTS.md and specifies corrective actions." .

<file:///app/compliance/protocols/pre-commit-protocol-001> proto:associatedTool <file:///app/compliance/protocols/code_linter>,
        <file:///app/compliance/protocols/pre_commit_instructions> ;
    proto:hasRule <file:///app/compliance/protocols/pre-commit-instructions-mandate> ;
    schema:description "Defines the mandatory pre-commit checks to ensure code quality, correctness, and readiness for submission." .

<file:///app/compliance/protocols/reset-all-prohibition-001> proto:associatedTool <file:///app/compliance/protocols/reset_all> ;
    proto:hasRule <file:///app/compliance/protocols/no-reset-all> ;
    schema:description "A high-priority protocol that unconditionally forbids the use of the `reset_all` tool." .

<file:///app/core/protocols/aorp-header> proto:hasRule <file:///app/core/protocols/aorp-identity>,
        <file:///app/core/protocols/aorp-versioning> ;
    schema:description "Defines the identity and versioning of the Advanced Orientation and Research Protocol (AORP)." .

<file:///app/core/protocols/cfdc-protocol-001> proto:associatedTool <file:///app/core/protocols/tooling/fdc_cli.py>,
        <file:///app/core/protocols/tooling/master_control.py> ;
    proto:hasRule <file:///app/core/protocols/hierarchical-planning-via-call-plan>,
        <file:///app/core/protocols/max-recursion-depth> ;
    schema:description """Defines the Context-Free Development Cycle (CFDC), a hierarchical planning and execution model.

**Associated Tool Documentation (`tooling/master_control.py`):**


  ### `/app/tooling/master_control.py`
  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).

  This script, master_control.py, is the heart of the agent's operational loop.
  It implements the CFDC, a hierarchical planning and execution model based on a
  Pushdown Automaton. This allows the agent to execute complex tasks by calling
  plans as sub-routines.

  Core Responsibilities:
  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable
    plans to call other plans via the `call_plan` directive. This allows for
    modular, reusable, and complex task decomposition. A maximum recursion depth
    is enforced to guarantee decidability.
  - **Plan Validation:** Contains the in-memory plan validator. Before execution,
    it parses a plan and simulates its execution against a Finite State Machine
    (FSM) to ensure it complies with the agent's operational protocols.
  - **"Registry-First" Plan Resolution:** When resolving a `call_plan` directive,
    it first attempts to look up the plan by its logical name in the
    `knowledge_core/plan_registry.json`. If not found, it falls back to treating
    the argument as a direct file path.
  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to
    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)
    to ensure predictable and auditable behavior.

  This module is designed as a library to be controlled by an external shell
  (e.g., `agent_shell.py`), making its interaction purely programmatic.

  **Public Classes:**

  - #### `class MasterControlGraph`
    > A Finite State Machine (FSM) that enforces the agent's protocol.
    > This graph reads a state definition and orchestrates the agent's workflow,
    > ensuring that all protocol steps are followed in the correct order.

    **Methods:**
    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`
    - ##### `def do_awaiting_result(self, agent_state, logger)`
      > Checks for the result of the background research process.
    - ##### `def do_debugging(self, agent_state, logger)`
      > Handles the debugging state.
    - ##### `def do_execution(self, agent_state, step_result, logger)`
      > Processes the result of a step and advances the execution state.
    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`
      > Handles the finalization of the task, guiding the agent through
      > the structured post-mortem process.
    - ##### `def do_generating_code(self, agent_state, logger)`
      > Handles the code generation state.
    - ##### `def do_orientation(self, agent_state, logger, tools)`
      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.
    - ##### `def do_planning(self, agent_state, plan_content, logger)`
      > Validates a given plan, parses it, and initializes the plan stack.
    - ##### `def do_researching(self, agent_state, logger)`
      > Launches the background research process.
    - ##### `def do_running_tests(self, agent_state, logger)`
      > Handles the test execution state.
    - ##### `def get_current_step(self, agent_state)`
      > Returns the current command to be executed by the agent, or None if execution is complete.
    - ##### `def get_trigger(self, source_state, dest_state)`
      > Finds a trigger in the FSM definition for a transition from a source
      > to a destination state. This is a helper to avoid hardcoding trigger
      > strings in the state handlers.
    - ##### `def validate_plan_for_model(self, plan_content, model)`
      > Validates a plan against a specific CSDC model using the LBAValidator.


**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/core/protocols/core-directive-001> proto:associatedTool <file:///app/core/protocols/tooling/fdc_cli.py> ;
    proto:hasRule <file:///app/core/protocols/mandatory-fdc-start> ;
    schema:description """The mandatory first action for any new task, ensuring a formal start to the Finite Development Cycle (FDC).

**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/core/protocols/decidability-constraints-001> proto:associatedTool <file:///app/core/protocols/tooling/fdc_cli.py>,
        <file:///app/core/protocols/tooling/fdc_fsm.json> ;
    proto:hasRule <file:///app/core/protocols/bounded-recursion>,
        <file:///app/core/protocols/fsm-adherence>,
        <file:///app/core/protocols/non-turing-completeness> ;
    schema:description """Ensures all development processes are formally decidable and computationally tractable.

**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/core/protocols/deep-research-cycle-001> proto:associatedTool <file:///app/core/protocols/create_file_with_block>,
        <file:///app/core/protocols/google_search>,
        <file:///app/core/protocols/view_text_website> ;
    proto:hasRule <file:///app/core/protocols/structured-research-phases> ;
    schema:description "A standardized, callable plan for conducting in-depth research on a complex topic." .

<file:///app/core/protocols/fdc-protocol-001> proto:associatedTool <file:///app/core/protocols/LOGGING_SCHEMA.md>,
        <file:///app/core/protocols/knowledge_core/dependency_graph.json>,
        <file:///app/core/protocols/knowledge_core/symbols.json>,
        <file:///app/core/protocols/message_user>,
        <file:///app/core/protocols/set_plan>,
        <file:///app/core/protocols/tooling/fdc_cli.py>,
        <file:///app/core/protocols/tooling/fdc_fsm.json> ;
    proto:hasRule <file:///app/core/protocols/fdc-entry-point>,
        <file:///app/core/protocols/fdc-state-transitions>,
        <file:///app/core/protocols/phase1-deconstruction>,
        <file:///app/core/protocols/phase2-planning>,
        <file:///app/core/protocols/phase3-execution>,
        <file:///app/core/protocols/phase4-post-mortem> ;
    schema:description """Defines the Finite Development Cycle (FDC), a formally defined process for executing a single, coherent task.

**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/core/protocols/orientation-cascade-001> proto:associatedTool <file:///app/core/protocols/google_search>,
        <file:///app/core/protocols/tooling/environmental_probe.py>,
        <file:///app/core/protocols/view_text_website> ;
    proto:hasRule <file:///app/core/protocols/l1-self-awareness>,
        <file:///app/core/protocols/l2-repository-sync>,
        <file:///app/core/protocols/l3-environmental-probing>,
        <file:///app/core/protocols/l4-deep-research-cycle> ;
    schema:description """Defines the mandatory, four-tiered orientation cascade that must be executed at the start of any task to establish a coherent model of the agent's identity, environment, and the world state.

**Associated Tool Documentation (`tooling/environmental_probe.py`):**


  ### `/app/tooling/environmental_probe.py`
  Performs a series of checks to assess the capabilities of the execution environment.

  This script is a critical diagnostic tool run at the beginning of a task to
  ensure the agent understands its operational sandbox. It verifies fundamental
  capabilities required for most software development tasks:

  1.  **Filesystem I/O:** Confirms that the agent can create, write to, read from,
      and delete files. It also provides a basic latency measurement for these
      operations.
  2.  **Network Connectivity:** Checks for external network access by attempting to
      connect to a highly-available public endpoint (google.com). This is crucial
      for tasks requiring `git` operations, package downloads, or API calls.
  3.  **Environment Variables:** Verifies that standard environment variables are
      accessible, which is a prerequisite for many command-line tools.

  The script generates a human-readable report summarizing the results of these
  probes, allowing the agent to quickly identify any environmental constraints
  that might impact its ability to complete a task.

  **Public Functions:**

  - #### `def main()`
    > Runs all environmental probes and prints a summary report.

  - #### `def probe_environment_variables()`
    > Checks for the presence of a common environment variable.

  - #### `def probe_filesystem()`
    > Tests file system write/read/delete capabilities and measures latency.

  - #### `def probe_network()`
    > Tests network connectivity and measures latency to a reliable external endpoint.
""" .

<file:///app/core/protocols/plan-registry-001> proto:associatedTool <file:///app/core/protocols/tooling/fdc_cli.py>,
        <file:///app/core/protocols/tooling/master_control.py>,
        <file:///app/core/protocols/tooling/plan_manager.py> ;
    proto:hasRule <file:///app/core/protocols/registry-definition>,
        <file:///app/core/protocols/registry-first-resolution>,
        <file:///app/core/protocols/registry-management-tool> ;
    schema:description """Defines a central registry for discovering and executing hierarchical plans by a logical name.

**Associated Tool Documentation (`tooling/plan_manager.py`):**


  ### `/app/tooling/plan_manager.py`
  Provides a command-line interface for managing the agent's Plan Registry.

  This script is the administrative tool for the Plan Registry, a key component
  of the Context-Free Development Cycle (CFDC) that enables hierarchical and
  modular planning. The registry, located at `knowledge_core/plan_registry.json`,
  maps human-readable, logical names to the file paths of specific plans. This
  decouples the `call_plan` directive from hardcoded file paths, making plans
  more reusable and the system more robust.

  This CLI provides three essential functions:
  - **register**: Associates a new logical name with a plan file path, adding it
    to the central registry.
  - **deregister**: Removes an existing logical name and its associated path from
    the registry.
  - **list**: Displays all current name-to-path mappings in the registry.

  By providing a simple, standardized interface for managing this library of
  reusable plans, this tool improves the agent's ability to compose complex
  workflows from smaller, validated sub-plans.

  **Public Functions:**

  - #### `def deregister_plan(name)`
    > Removes a plan from the registry by its logical name.

  - #### `def get_registry()`
    > Loads the plan registry from its JSON file.

  - #### `def list_plans()`
    > Lists all currently registered plans.

  - #### `def main()`
    > Main function to run the plan management CLI.

  - #### `def register_plan(name, path)`
    > Registers a new plan by mapping a logical name to a file path.

  - #### `def save_registry(registry_data)`
    > Saves the given data to the plan registry JSON file.


**Associated Tool Documentation (`tooling/master_control.py`):**


  ### `/app/tooling/master_control.py`
  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).

  This script, master_control.py, is the heart of the agent's operational loop.
  It implements the CFDC, a hierarchical planning and execution model based on a
  Pushdown Automaton. This allows the agent to execute complex tasks by calling
  plans as sub-routines.

  Core Responsibilities:
  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable
    plans to call other plans via the `call_plan` directive. This allows for
    modular, reusable, and complex task decomposition. A maximum recursion depth
    is enforced to guarantee decidability.
  - **Plan Validation:** Contains the in-memory plan validator. Before execution,
    it parses a plan and simulates its execution against a Finite State Machine
    (FSM) to ensure it complies with the agent's operational protocols.
  - **"Registry-First" Plan Resolution:** When resolving a `call_plan` directive,
    it first attempts to look up the plan by its logical name in the
    `knowledge_core/plan_registry.json`. If not found, it falls back to treating
    the argument as a direct file path.
  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to
    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)
    to ensure predictable and auditable behavior.

  This module is designed as a library to be controlled by an external shell
  (e.g., `agent_shell.py`), making its interaction purely programmatic.

  **Public Classes:**

  - #### `class MasterControlGraph`
    > A Finite State Machine (FSM) that enforces the agent's protocol.
    > This graph reads a state definition and orchestrates the agent's workflow,
    > ensuring that all protocol steps are followed in the correct order.

    **Methods:**
    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`
    - ##### `def do_awaiting_result(self, agent_state, logger)`
      > Checks for the result of the background research process.
    - ##### `def do_debugging(self, agent_state, logger)`
      > Handles the debugging state.
    - ##### `def do_execution(self, agent_state, step_result, logger)`
      > Processes the result of a step and advances the execution state.
    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`
      > Handles the finalization of the task, guiding the agent through
      > the structured post-mortem process.
    - ##### `def do_generating_code(self, agent_state, logger)`
      > Handles the code generation state.
    - ##### `def do_orientation(self, agent_state, logger, tools)`
      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.
    - ##### `def do_planning(self, agent_state, plan_content, logger)`
      > Validates a given plan, parses it, and initializes the plan stack.
    - ##### `def do_researching(self, agent_state, logger)`
      > Launches the background research process.
    - ##### `def do_running_tests(self, agent_state, logger)`
      > Handles the test execution state.
    - ##### `def get_current_step(self, agent_state)`
      > Returns the current command to be executed by the agent, or None if execution is complete.
    - ##### `def get_trigger(self, source_state, dest_state)`
      > Finds a trigger in the FSM definition for a transition from a source
      > to a destination state. This is a helper to avoid hardcoding trigger
      > strings in the state handlers.
    - ##### `def validate_plan_for_model(self, plan_content, model)`
      > Validates a plan against a specific CSDC model using the LBAValidator.


**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/core/protocols/research-fdc-001> proto:associatedTool <file:///app/core/protocols/tooling/fdc_cli.py>,
        <file:///app/core/protocols/tooling/master_control.py>,
        <file:///app/core/protocols/tooling/research.py>,
        <file:///app/core/protocols/tooling/research_planner.py> ;
    proto:hasRule <file:///app/core/protocols/executable-plans>,
        <file:///app/core/protocols/l4-invocation>,
        <file:///app/core/protocols/specialized-fsm> ;
    schema:description """Defines the formal Finite Development Cycle (FDC) for conducting deep research.

**Associated Tool Documentation (`tooling/master_control.py`):**


  ### `/app/tooling/master_control.py`
  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).

  This script, master_control.py, is the heart of the agent's operational loop.
  It implements the CFDC, a hierarchical planning and execution model based on a
  Pushdown Automaton. This allows the agent to execute complex tasks by calling
  plans as sub-routines.

  Core Responsibilities:
  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable
    plans to call other plans via the `call_plan` directive. This allows for
    modular, reusable, and complex task decomposition. A maximum recursion depth
    is enforced to guarantee decidability.
  - **Plan Validation:** Contains the in-memory plan validator. Before execution,
    it parses a plan and simulates its execution against a Finite State Machine
    (FSM) to ensure it complies with the agent's operational protocols.
  - **"Registry-First" Plan Resolution:** When resolving a `call_plan` directive,
    it first attempts to look up the plan by its logical name in the
    `knowledge_core/plan_registry.json`. If not found, it falls back to treating
    the argument as a direct file path.
  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to
    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)
    to ensure predictable and auditable behavior.

  This module is designed as a library to be controlled by an external shell
  (e.g., `agent_shell.py`), making its interaction purely programmatic.

  **Public Classes:**

  - #### `class MasterControlGraph`
    > A Finite State Machine (FSM) that enforces the agent's protocol.
    > This graph reads a state definition and orchestrates the agent's workflow,
    > ensuring that all protocol steps are followed in the correct order.

    **Methods:**
    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`
    - ##### `def do_awaiting_result(self, agent_state, logger)`
      > Checks for the result of the background research process.
    - ##### `def do_debugging(self, agent_state, logger)`
      > Handles the debugging state.
    - ##### `def do_execution(self, agent_state, step_result, logger)`
      > Processes the result of a step and advances the execution state.
    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`
      > Handles the finalization of the task, guiding the agent through
      > the structured post-mortem process.
    - ##### `def do_generating_code(self, agent_state, logger)`
      > Handles the code generation state.
    - ##### `def do_orientation(self, agent_state, logger, tools)`
      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.
    - ##### `def do_planning(self, agent_state, plan_content, logger)`
      > Validates a given plan, parses it, and initializes the plan stack.
    - ##### `def do_researching(self, agent_state, logger)`
      > Launches the background research process.
    - ##### `def do_running_tests(self, agent_state, logger)`
      > Handles the test execution state.
    - ##### `def get_current_step(self, agent_state)`
      > Returns the current command to be executed by the agent, or None if execution is complete.
    - ##### `def get_trigger(self, source_state, dest_state)`
      > Finds a trigger in the FSM definition for a transition from a source
      > to a destination state. This is a helper to avoid hardcoding trigger
      > strings in the state handlers.
    - ##### `def validate_plan_for_model(self, plan_content, model)`
      > Validates a plan against a specific CSDC model using the LBAValidator.


**Associated Tool Documentation (`tooling/research_planner.py`):**


  ### `/app/tooling/research_planner.py`
  This module is responsible for generating a formal, FSM-compliant research plan
  for a given topic. The output is a string that can be executed by the agent's
  master controller.

  **Public Functions:**

  - #### `def plan_deep_research(topic, research_id)`
    > Generates a multi-step, FSM-compliant plan for conducting deep research
    > using the official project templates.
    >
    > Args:
    >     topic (str): The research topic.
    >     research_id (str): A unique ID for this research task.
    >
    > Returns:
    >     str: A string containing the executable plan.


**Associated Tool Documentation (`tooling/research.py`):**


  ### `/app/tooling/research.py`
  This module contains the logic for executing research tasks based on a set of
  constraints. It acts as a dispatcher, calling the appropriate tool (e.g.,
  read_file, google_search) based on the specified target and scope.

  **Public Functions:**

  - #### `def execute_research_protocol(constraints)`
    > Executes a research task based on a provided constraints dictionary.
    >
    > Args:
    >     constraints (dict): A dictionary specifying the research target,
    >                         scope, and other parameters.
    >
    > Returns:
    >     str: The result of the research action, or an error message.


**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/core/protocols/research-protocol-001> proto:associatedTool <file:///app/core/protocols/tooling.research.execute_research_protocol>,
        <file:///app/core/protocols/tooling.research_planner.plan_deep_research> ;
    proto:hasRule <file:///app/core/protocols/mandate-research-tools> ;
    schema:description "A protocol for conducting systematic research using the integrated research toolchain." .

<file:///app/core/protocols/self-correction-protocol-001> proto:associatedTool <file:///app/core/protocols/initiate_memory_recording>,
        <file:///app/core/protocols/tooling/code_suggester.py>,
        <file:///app/core/protocols/tooling/knowledge_compiler.py>,
        <file:///app/core/protocols/tooling/protocol_updater.py>,
        <file:///app/core/protocols/tooling/self_correction_orchestrator.py> ;
    proto:hasRule <file:///app/core/protocols/automated-orchestration>,
        <file:///app/core/protocols/autonomous-code-suggestion>,
        <file:///app/core/protocols/programmatic-rule-refinement>,
        <file:///app/core/protocols/programmatic-updates>,
        <file:///app/core/protocols/structured-lessons> ;
    schema:description """Defines the automated, closed-loop workflow for protocol self-correction.

**Associated Tool Documentation (`tooling/knowledge_compiler.py`):**


  ### `/app/tooling/knowledge_compiler.py`
  Extracts structured lessons from post-mortem reports and compiles them into a
  centralized, long-term knowledge base.

  This script is a core component of the agent's self-improvement feedback loop.
  After a task is completed, a post-mortem report is generated that includes a
  section for "Corrective Actions & Lessons Learned." This script automates the
  process of parsing that section to extract key insights.

  It identifies pairs of "Lesson" and "Action" statements and transforms them
  into a standardized, machine-readable format. These formatted entries are then
  appended to the `knowledge_core/lessons.jsonl` file, which serves as the
  agent's persistent memory of what has worked, what has failed, and what can be
  improved in future tasks.

  The script is executed via the command line, taking the path to a completed
  post-mortem file as its primary argument.

  **Public Functions:**

  - #### `def extract_lessons_from_postmortem(postmortem_content)`
    > Parses a post-mortem report to extract lessons learned.
    > Handles multiple possible section headers and formats.

  - #### `def extract_metadata_from_postmortem(postmortem_content)`
    > Parses a post-mortem report to extract metadata like Task ID and Date.

  - #### `def format_lesson_entry(metadata, lesson_data)`
    > Formats an extracted lesson into a structured JSON object.

  - #### `def main()`

  - #### `def parse_action_to_command(action_text)`
    > Parses a natural language action string into a machine-executable command.
    >
    > This is the core of translating insights into automated actions. It uses
    > pattern matching to identify specific, supported commands.


**Associated Tool Documentation (`tooling/protocol_updater.py`):**


  ### `/app/tooling/protocol_updater.py`
  A command-line tool for programmatically updating protocol source files.

  This script provides the mechanism for the agent to perform self-correction
  by modifying its own governing protocols based on structured, actionable
  lessons. It is a key component of the Protocol-Driven Self-Correction (PDSC)
  workflow.

  The tool operates on the .protocol.json files located in the `protocols/`
  directory, performing targeted updates based on command-line arguments.

  **Public Functions:**

  - #### `def add_tool_to_protocol(protocol_id, tool_name, protocols_dir)`
    > Adds a tool to the 'associated_tools' list of a specified protocol.

  - #### `def find_protocol_file(protocol_id, protocols_dir)`
    > Recursively finds the protocol file path corresponding to a given protocol_id.

  - #### `def main()`
    > Main function to parse arguments and call the appropriate handler.

  - #### `def update_rule_in_protocol(protocol_id, rule_id, new_description, protocols_dir)`
    > Updates the description of a specific rule within a protocol.


**Associated Tool Documentation (`tooling/self_correction_orchestrator.py`):**


  ### `/app/tooling/self_correction_orchestrator.py`
  Orchestrates the Protocol-Driven Self-Correction (PDSC) workflow.

  This script is the engine of the automated feedback loop. It reads structured,
  actionable lessons from `knowledge_core/lessons.jsonl` and uses the
  `protocol_updater.py` tool to apply them to the source protocol files.

  **Public Functions:**

  - #### `def load_lessons()`
    > Loads all lessons from the JSONL file.

  - #### `def main()`
    > Main function to run the self-correction workflow.

  - #### `def process_lessons(lessons, protocols_dir)`
    > Processes all pending lessons, applies them, and updates their status.
    > Returns True if any changes were made, False otherwise.

  - #### `def run_command(command)`
    > Runs a command and returns True on success, False on failure.

  - #### `def save_lessons(lessons)`
    > Saves a list of lessons back to the JSONL file, overwriting it.


**Associated Tool Documentation (`tooling/code_suggester.py`):**


  ### `/app/tooling/code_suggester.py`
  Handles the generation and application of autonomous code change suggestions.

  This tool is a key component of the advanced self-correction loop. It is
  designed to be invoked by the self-correction orchestrator when a lesson
  contains a 'propose-code-change' action.

  For its initial implementation, this tool acts as a structured executor. It
  takes a lesson where the 'details' field contains a fully-formed git-style
  merge diff and applies it to the target file. It does this by generating a
  temporary, single-step plan file and signaling its location for the master
  controller to execute.

  This establishes the fundamental workflow for autonomous code modification,
  decoupling the suggestion logic from the execution logic. Future iterations
  can enhance this tool with more sophisticated code generation capabilities
  (e.g., using an LLM to generate the diff from a natural language description)
  without altering the core orchestration process.

  **Public Functions:**

  - #### `def generate_suggestion_plan(filepath, diff_content)`
    > Generates a temporary, single-step plan file to apply a code change.
    >
    > Args:
    >     filepath: The path to the file that needs to be modified.
    >     diff_content: The git-style merge diff block to be applied.
    >
    > Returns:
    >     The path to the generated temporary plan file.

  - #### `def main()`
    > Main entry point for the code suggester tool.
    > Parses arguments, generates a plan, and prints the plan's path to stdout.
""" .

<file:///app/core/protocols/standing-orders-001> proto:associatedTool <file:///app/core/protocols/google_search>,
        <file:///app/core/protocols/tooling/fdc_cli.py>,
        <file:///app/core/protocols/view_text_website> ;
    proto:hasRule <file:///app/core/protocols/aorp-mandate>,
        <file:///app/core/protocols/fdc-toolchain-mandate>,
        <file:///app/core/protocols/rag-mandate> ;
    schema:description """A set of non-negotiable, high-priority mandates that govern the agent's behavior across all tasks.

**Associated Tool Documentation (`tooling/fdc_cli.py`):**


  ### `/app/tooling/fdc_cli.py`
  This script provides a command-line interface (CLI) for managing the Finite
  Development Cycle (FDC).

  The FDC is a structured workflow for agent-driven software development. This CLI
  is the primary human interface for interacting with that cycle, providing
  commands to:
  - **start:** Initiates a new development task, triggering the "Advanced
    Orientation and Research Protocol" (AORP) to ensure the agent is fully
    contextualized.
  - **close:** Formally concludes a task, creating a post-mortem template for
    analysis and lesson-learning.
  - **validate:** Checks a given plan file for both syntactic and semantic
    correctness against the FDC's governing Finite State Machine (FSM). This
    ensures that a plan is executable and will not violate protocol.
  - **analyze:** Examines a plan to determine its computational complexity (e.g.,
    Constant, Polynomial, Exponential) and its modality (Read-Only vs.
    Read-Write), providing insight into the plan's potential impact.

  **Public Functions:**

  - #### `def analyze_plan(plan_filepath, return_results=False)`
    > Analyzes a plan file to determine its complexity class and modality.

  - #### `def close_task(task_id)`
    > Automates the closing of a Finite Development Cycle.

  - #### `def main()`

  - #### `def start_task(task_id)`
    > Initiates the AORP cascade for a new task.

  - #### `def validate_plan(plan_filepath)`
""" .

<file:///app/critic/protocols/critic-meta-protocol-001> proto:hasRule <file:///app/critic/protocols/built-in-tools-are-valid>,
        <file:///app/critic/protocols/functional-change-definition>,
        <file:///app/critic/protocols/protocol-as-source-code> ;
    schema:description "A meta-protocol that governs the behavior and evaluation criteria of the Code Review Critic agent." .

<file:///app/critic/protocols/critic-reset-prohibition-001> proto:associatedTool <file:///app/critic/protocols/reset_all> ;
    proto:hasRule <file:///app/critic/protocols/critic-no-reset> ;
    schema:description "A specific, high-priority protocol that forbids the Code Review Critic agent from using the 'reset_all' tool." .

<file:///app/protocols/agent-bootstrap-001> proto:associatedTool <file:///app/protocols/read_file> ;
    proto:hasRule <file:///app/protocols/bootstrap-load-agents-md> ;
    schema:description "A foundational protocol that dictates the agent's initial actions upon starting any task." .

<file:///app/protocols/agent-interaction-001> proto:associatedTool <file:///app/protocols/message_user>,
        <file:///app/protocols/set_plan> ;
    proto:hasRule <file:///app/protocols/communication-tool-access>,
        <file:///app/protocols/planning-tool-access> ;
    schema:description "A protocol governing the agent's core interaction and planning tools." .

<file:///app/protocols/agent-shell-001> proto:associatedTool <file:///app/protocols/tooling/agent_shell.py> ;
    proto:hasRule <file:///app/protocols/shell-is-primary-entry-point> ;
    schema:description """A protocol governing the use of the interactive agent shell as the primary entry point for all tasks.

**Associated Tool Documentation (`tooling/agent_shell.py`):**


  ### `/app/tooling/agent_shell.py`
  The new, interactive, API-driven entry point for the agent.

  This script replaces the old file-based signaling system with a direct,
  programmatic interface to the MasterControlGraph FSM. It is responsible for:
  1.  Initializing the agent's state and a centralized logger.
  2.  Instantiating and running the MasterControlGraph.
  3.  Driving the FSM by calling its methods and passing data and the logger.
  4.  Containing the core "agent logic" (e.g., an LLM call) to generate plans
      and respond to requests for action.

  **Public Functions:**

  - #### `def find_fsm_transition(fsm, source_state, trigger)`
    > Finds the destination state for a given source and trigger.

  - #### `def main()`
    > Main entry point for the agent shell.

  - #### `def run_agent_loop(task_description, tools, model=None)`
    > The main loop that drives the agent's lifecycle via the FSM.
""" .

<file:///app/protocols/aura-execution-001> proto:associatedTool <file:///app/protocols/tooling/aura_executor.py> ;
    proto:hasRule <file:///app/protocols/execute-aura-script> ;
    schema:description """A protocol for executing Aura scripts, enabling a more expressive and powerful planning and automation language for the agent.

**Associated Tool Documentation (`tooling/aura_executor.py`):**


  ### `/app/tooling/aura_executor.py`
  This script serves as the command-line executor for `.aura` files.

  It bridges the gap between the high-level Aura scripting language and the
  agent's underlying Python-based toolset. The executor is responsible for:
  1.  Parsing the `.aura` source code using the lexer and parser from the
      `aura_lang` package.
  2.  Setting up an execution environment for the interpreter.
  3.  Injecting a "tool-calling" capability into the Aura environment, which
      allows Aura scripts to dynamically invoke registered Python tools
      (e.g., `hdl_prover`, `environmental_probe`).
  4.  Executing the parsed program and printing the final result.

  This makes it a key component for enabling more expressive and complex
  automation scripts for the agent.

  **Public Functions:**

  - #### `def dynamic_agent_call_tool(tool_name_obj, *args)`
    > Dynamically imports and calls a tool from the 'tooling' directory and wraps the result.
    >
    > This function provides the bridge between the Aura scripting environment and the
    > Python-based agent tools. It takes the tool's module name and arguments,
    > runs the tool in a subprocess, and wraps the captured output in an Aura `Object`.
    >
    > Args:
    >     tool_name_obj: An Aura Object containing the tool's module name (e.g., 'hdl_prover').
    >     *args: A variable number of Aura Objects to be passed as string arguments to the tool.
    >
    > Returns:
    >     An Aura `Object` containing the tool's stdout as a string, or an error message.

  - #### `def main()`
    > Main entry point for the Aura script executor.
""" .

<file:///app/protocols/capability-verification-001> proto:associatedTool <file:///app/protocols/tooling/capability_verifier.py> ;
    proto:hasRule <file:///app/protocols/verify-capability-acquisition> ;
    schema:description """A protocol for using the capability verifier tool to empirically test the agent's monotonic improvement.

**Associated Tool Documentation (`tooling/capability_verifier.py`):**


  ### `/app/tooling/capability_verifier.py`
  A tool to verify that the agent can monotonically improve its capabilities.

  This script is designed to provide a formal, automated test for the agent's
  self-correction and learning mechanisms. It ensures that when the agent learns
  a new capability, it does so without losing (regressing) any of its existing
  capabilities. This is a critical safeguard for ensuring robust and reliable
  agent evolution.

  The tool works by orchestrating a four-step process:
  1.  **Confirm Initial Failure:** It runs a specific test file that is known to
      fail, verifying that the agent currently lacks the target capability.
  2.  **Invoke Self-Correction:** It simulates the discovery of a new "lesson" and
      triggers the `self_correction_orchestrator.py` script, which is responsible
      for integrating new knowledge and skills.
  3.  **Confirm Final Success:** It runs the same test file again, confirming that
      the agent has successfully learned the new capability and the test now passes.
  4.  **Check for Regressions:** It runs the full, existing test suite to ensure
      that the process of learning the new skill has not inadvertently broken any
      previously functional capabilities.

  This provides a closed-loop verification of monotonic improvement, which is a
  cornerstone of the agent's design philosophy.

  **Public Functions:**

  - #### `def main()`
    > A tool to verify that the agent can monotonically improve its capabilities.
    >
    > This tool works by:
    > 1. Running a target test file that is known to fail, confirming the agent lacks a capability.
    > 2. Invoking the agent's self-correction mechanism to learn the new capability.
    > 3. Running the target test again to confirm it now passes.
    > 4. Running the full test suite to ensure no existing capabilities were lost.
""" .

<file:///app/protocols/csdc-001> proto:associatedTool <file:///app/protocols/tooling/csdc_cli.py> ;
    proto:hasRule <file:///app/protocols/model-a-constraints>,
        <file:///app/protocols/model-b-constraints>,
        <file:///app/protocols/use-csdc-cli> ;
    schema:description """A protocol for the Context-Sensitive Development Cycle (CSDC), which introduces development models based on logical constraints.

**Associated Tool Documentation (`tooling/csdc_cli.py`):**


  ### `/app/tooling/csdc_cli.py`
  A command-line tool for managing the Context-Sensitive Development Cycle (CSDC).

  This script provides an interface to validate a development plan against a specific
  CSDC model (A or B) and a given complexity class (P or EXP). It ensures that a
  plan adheres to the strict logical and computational constraints defined by the
  CSDC protocol before it is executed.

  The tool performs two main checks:
  1.  **Complexity Analysis:** It analyzes the plan to determine its computational
      complexity and verifies that it matches the expected complexity class.
  2.  **Model Validation:** It validates the plan's commands against the rules of
      the specified CSDC model, ensuring that it does not violate any of the
      model's constraints (e.g., forbidding certain functions).

  This serves as a critical gateway for ensuring that all development work within
  the CSDC framework is sound, predictable, and compliant with the governing
  meta-mathematical principles.

  **Public Functions:**

  - #### `def main()`
""" .

<file:///app/protocols/dependency-management-001> proto:associatedTool <file:///app/protocols/run_in_bash_session> ;
    proto:hasRule <file:///app/protocols/dependency-install-on-start> ;
    schema:description "A protocol for ensuring a reliable execution environment through formal dependency management." .

<file:///app/protocols/experimental-prologue-001> proto:associatedTool <file:///app/protocols/create_file_with_block> ;
    proto:hasRule <file:///app/protocols/create-prologue-file> ;
    schema:description "An experimental protocol to test dynamic rule-following. It mandates a prologue action before file creation." .

<file:///app/protocols/file-indexing-001> proto:associatedTool <file:///app/protocols/tooling/file_indexer.py> ;
    proto:hasRule <file:///app/protocols/update-index-before-submit> ;
    schema:description """A protocol for maintaining an up-to-date file index to accelerate tool performance.

*Documentation Warning: Tool `tooling/file_indexer.py` not found.*

*Documentation Warning: Tool `tooling/file_indexer.py` not found.*""" .

<file:///app/protocols/hdl-proving-001> proto:associatedTool <file:///app/protocols/tooling/hdl_prover.py> ;
    proto:hasRule <file:///app/protocols/prove-sequent> ;
    schema:description """A protocol for interacting with the Hypersequent-calculus-based logic engine, allowing the agent to perform formal logical proofs.

**Associated Tool Documentation (`tooling/hdl_prover.py`):**


  ### `/app/tooling/hdl_prover.py`
  A command-line tool for proving sequents in Intuitionistic Linear Logic.

  This script provides a basic interface to a simple logic prover. It takes a
  sequent as a command-line argument, parses it into a logical structure, and
  then attempts to prove it using a rudimentary proof search algorithm.

  The primary purpose of this tool is to allow the agent to perform formal
  reasoning and verification tasks by checking the validity of logical entailments.
  For example, it can be used to verify that a certain conclusion follows from a
  set of premises according to the rules of linear logic.

  The current implementation uses a very basic parser and proof algorithm,
  serving as a placeholder and demonstration for a more sophisticated, underlying
  logic engine.

  **Public Functions:**

  - #### `def main()`

  - #### `def parse_formula(s)`
    > A very basic parser for formulas.

  - #### `def parse_sequent(s)`
    > A very basic parser for sequents.

  - #### `def prove_sequent(sequent)`
    > A very simple proof search algorithm.
    > This is a placeholder for a more sophisticated prover.
""" .

<file:///app/protocols/plllu-execution-001> proto:associatedTool <file:///app/protocols/tooling/plllu_runner.py> ;
    proto:hasRule <file:///app/protocols/execute-plllu-script> ;
    schema:description """A protocol for executing pLLLU scripts, enabling a more expressive and powerful planning and automation language for the agent.

**Associated Tool Documentation (`tooling/plllu_runner.py`):**


  ### `/app/tooling/plllu_runner.py`
  A command-line runner for pLLLU files.

  This script provides an entry point for executing `.plllu` files. It
  integrates the pLLLU lexer, parser, and interpreter to execute the logic
  defined in a given pLLLU source file and print the result.

  **Public Functions:**

  - #### `def main()`
    > This tool provides a command-line interface for running .plllu files.
    > It integrates the pLLLU lexer, parser, and interpreter to execute
    > the logic defined in a given pLLLU source file.
""" .

<file:///app/protocols/security/security-header> schema:description "Defines the identity and purpose of the Security Protocol document." .

<file:///app/protocols/security/security-vuln-reporting-001> proto:hasRule <file:///app/protocols/security/no-public-disclosure>,
        <file:///app/protocols/security/vuln-reporting-channel> ;
    schema:description "Defines the official policy and procedure for reporting security vulnerabilities." .

<file:///app/protocols/speculative-execution-001> proto:associatedTool <file:///app/protocols/create_file_with_block>,
        <file:///app/protocols/request_user_input>,
        <file:///app/protocols/set_plan> ;
    proto:hasRule <file:///app/protocols/formal-proposal-required>,
        <file:///app/protocols/idle-state-trigger>,
        <file:///app/protocols/resource-constraints>,
        <file:///app/protocols/speculative-logging>,
        <file:///app/protocols/user-review-gate> ;
    schema:description "A protocol that governs the agent's ability to initiate and execute self-generated, creative, or exploratory tasks during idle periods." .

<file:///app/protocols/toolchain-review-on-schema-change-001> proto:associatedTool <file:///app/protocols/tooling/hierarchical_compiler.py>,
        <file:///app/protocols/tooling/protocol_auditor.py>,
        <file:///app/protocols/tooling/protocol_compiler.py> ;
    proto:hasRule <file:///app/protocols/toolchain-audit-on-schema-change> ;
    schema:description """A meta-protocol to ensure the agent's toolchain remains synchronized with the architecture of its governing protocols.

*Documentation Warning: Tool `tooling/protocol_auditor.py` not found.*

*Documentation Warning: Tool `tooling/protocol_auditor.py` not found.*

**Associated Tool Documentation (`tooling/protocol_compiler.py`):**


  ### `/app/tooling/protocol_compiler.py`
  Compiles source protocol files into unified, human-readable and machine-readable artifacts.

  This script is the engine behind the "protocol as code" principle. It discovers,
  validates, and assembles protocol definitions from a source directory (e.g., `protocols/`)
  into high-level documents like `AGENTS.md`.

  Key Functions:
  - **Discovery:** Scans a directory for source files, including `.protocol.json`
    (machine-readable rules) and `.protocol.md` (human-readable context).
  - **Validation:** Uses a JSON schema (`protocol.schema.json`) to validate every
    `.protocol.json` file, ensuring all protocol definitions are syntactically
    correct and adhere to the established structure.
  - **Compilation:** Combines the human-readable markdown and the machine-readable
    JSON into a single, cohesive Markdown file, embedding the JSON in code blocks.
  - **Documentation Injection:** Can inject other generated documents, like the
    `SYSTEM_DOCUMENTATION.md`, into the final output at specified locations.
  - **Knowledge Graph Generation:** Optionally, it can process the validated JSON
    protocols and serialize them into an RDF knowledge graph (in Turtle format),
    creating a machine-queryable version of the agent's governing rules.

  This process ensures that `AGENTS.md` and other protocol documents are not edited
  manually but are instead generated from a validated, single source of truth,
  making the agent's protocols robust, verifiable, and maintainable.

  **Public Functions:**

  - #### `def compile_protocols(source_dir, target_file, schema_file, knowledge_graph_file=None, autodoc_file=None)`
    > Reads all .protocol.json and corresponding .protocol.md files from the
    > source directory, validates them, and compiles them into a target markdown file.
    > Optionally, it can also generate a machine-readable knowledge graph.

  - #### `def install_dependencies()`
    > Checks for required packages from requirements.txt and installs them if missing.

  - #### `def load_schema(schema_file)`
    > Loads the protocol JSON schema.

  - #### `def main_cli()`
    > Main function to run the compiler from the command line.

  - #### `def sanitize_markdown(content)`
    > Sanitizes markdown content to remove potentially malicious instructions.
    > This function removes script tags and other potentially malicious HTML/JS.


**Associated Tool Documentation (`tooling/hierarchical_compiler.py`):**


  ### `/app/tooling/hierarchical_compiler.py`
  A hierarchical build system for compiling nested protocol modules.

  This script orchestrates the compilation of `AGENTS.md` and `README.md` files
  across a repository with a nested or hierarchical module structure. It is a key
  component of the system's ability to manage complexity by allowing protocols to
  be defined in a modular, distributed way while still being presented as a unified,
  coherent whole at each level of the hierarchy.

  The compiler operates in two main passes:

  **Pass 1: Documentation Compilation (Bottom-Up)**
  1.  **Discovery:** It finds all `protocols` directories in the repository, which
      signify the root of a documentation module.
  2.  **Bottom-Up Traversal:** It processes these directories from the most deeply
      nested ones upwards. This ensures that child modules are always built before
      their parents.
  3.  **Child Summary Injection:** For each compiled child module, it generates a
      summary of its protocols and injects this summary into the parent's
      `protocols` directory as a temporary file.
  4.  **Parent Compilation:** When the parent module is compiled, the standard
      `protocol_compiler.py` automatically includes the injected child summaries,
      creating a single `AGENTS.md` file that contains both the parent's native
      protocols and the full protocols of all its direct children.
  5.  **README Generation:** After each `AGENTS.md` is compiled, the corresponding
      `README.md` is generated.

  **Pass 2: Centralized Knowledge Graph Compilation**
  1.  After all documentation is built, it performs a full repository scan to find
      every `*.protocol.json` file.
  2.  It parses all of these files and compiles them into a single, centralized
      RDF knowledge graph (`protocols.ttl`). This provides a unified,
      machine-readable view of every protocol defined anywhere in the system.

  This hierarchical approach allows for both localized, context-specific protocol
  definitions and a holistic, system-wide understanding of the agent's governing rules.

  **Public Functions:**

  - #### `def cleanup_summaries(directory)`
    > Removes temporary summary files from a protocols directory.

  - #### `def compile_centralized_knowledge_graph()`
    > Finds all protocol.json files in the entire repository, loads them, and
    > compiles them into a single, unified knowledge graph.

  - #### `def enrich_protocol_descriptions(source_dir)`
    > Finds protocol.json files, checks for associated tools,
    > and injects their documentation into the description.

  - #### `def find_protocol_dirs(root_dir)`
    > Finds all directories named 'protocols' within the root directory,
    > ignoring any special-cased directories.

  - #### `def generate_summary(child_agents_md_path)`
    > Extracts the full, rendered protocol blocks from a child AGENTS.md file.
    > This function finds all protocol definitions (human-readable markdown and
    > the associated machine-readable JSON block) and concatenates them into a
    > single string to be injected into the parent AGENTS.md.

  - #### `def get_parent_module(module_path, all_module_paths)`
    > Finds the direct parent module of a given module.

  - #### `def get_tool_documentation(tool_path)`
    > Uses the doc_builder to extract documentation for a specific tool.

  - #### `def main()`
    > Main function to orchestrate the hierarchical compilation.

  - #### `def run_compiler(source_dir)`
    > Invokes the protocol_compiler.py script as a library.

  - #### `def run_readme_generator(source_agents_md)`
    > Invokes the doc_builder.py script to generate a README.
""" .

<file:///app/protocols/unified-auditor-001> proto:associatedTool <file:///app/protocols/tooling/auditor.py> ;
    proto:hasRule <file:///app/protocols/run-all-audits> ;
    schema:description """A protocol for the unified repository auditing tool, which combines multiple health and compliance checks into a single interface.

**Associated Tool Documentation (`tooling/auditor.py`):**


  ### `/app/tooling/auditor.py`
  A unified auditing tool for maintaining repository health and compliance.

  This script combines the functionality of several disparate auditing tools into a
  single, comprehensive command-line interface. It serves as the central tool for
  validating the key components of the agent's architecture, including protocols,
  plans, and documentation.

  The auditor can perform the following checks:
  1.  **Protocol Audit (`protocol`):**
      - Checks if `AGENTS.md` artifacts are stale compared to their source files.
      - Verifies protocol completeness by comparing tools used in logs against
        tools defined in protocols.
      - Analyzes tool usage frequency (centrality).
  2.  **Plan Registry Audit (`plans`):**
      - Scans `knowledge_core/plan_registry.json` for "dead links" where the
        target plan file does not exist.
  3.  **Documentation Audit (`docs`):**
      - Scans the generated `SYSTEM_DOCUMENTATION.md` to find Python modules
        that are missing module-level docstrings.

  The tool is designed to be run from the command line and can execute specific
  audits or all of them, generating a consolidated `audit_report.md` file.

  **Public Functions:**

  - #### `def find_all_agents_md_files(root_dir)`

  - #### `def get_protocol_tools_from_agents_md(agents_md_paths)`

  - #### `def get_used_tools_from_log(log_path)`

  - #### `def main()`

  - #### `def run_doc_audit()`

  - #### `def run_plan_registry_audit()`

  - #### `def run_protocol_audit()`
""" .

<file:///app/protocols/unified-doc-builder-001> proto:associatedTool <file:///app/protocols/tooling/doc_builder.py> ;
    proto:hasRule <file:///app/protocols/use-doc-builder-for-all-docs> ;
    schema:description """A protocol for the unified documentation builder, which generates various documentation artifacts from the repository's sources of truth.

**Associated Tool Documentation (`tooling/doc_builder.py`):**


  ### `/app/tooling/doc_builder.py`
  A unified documentation builder for the project.
  ...

  **Public Functions:**

  - #### `def find_python_files(directories)`

  - #### `def format_args(args)`

  - #### `def generate_documentation_for_module(mod_doc)`

  - #### `def generate_pages(readme_path, agents_md_path, output_file)`
    > Generates the index.html for GitHub Pages.

  - #### `def generate_readme(agents_md_path, output_file)`
    > Generates the high-level README.md for a module.

  - #### `def generate_system_docs(source_dirs, output_file)`
    > Generates the detailed SYSTEM_DOCUMENTATION.md.

  - #### `def get_module_docstring(filepath)`
    > Parses a Python file and extracts its module-level docstring.

  - #### `def get_protocol_summary(agents_md_path)`
    > Parses an AGENTS.md file and extracts a list of protocol summaries.

  - #### `def main()`

  - #### `def parse_file_for_docs(filepath)`


  **Public Classes:**

  - #### `class ClassDoc`

    **Methods:**
    - ##### `def __init__(self, name, docstring, methods)`

  - #### `class DocVisitor`

    **Methods:**
    - ##### `def __init__(self)`
    - ##### `def visit_ClassDef(self, node)`
    - ##### `def visit_FunctionDef(self, node)`

  - #### `class FunctionDoc`

    **Methods:**
    - ##### `def __init__(self, name, signature, docstring)`

  - #### `class ModuleDoc`

    **Methods:**
    - ##### `def __init__(self, name, docstring, classes, functions)`
""" .

<file:///app/compliance/protocols/agents-md-self-awareness> proto:enforcement "The agent should incorporate this check into its standard operating procedure, particularly at the beginning of a task or when unexpected behavior occurs." ;
    schema:description "The AGENTS.md file is a build artifact generated from source files in the 'protocols/' directory. Before relying on AGENTS.md, the agent should ensure it is up-to-date by running 'make AGENTS.md'. This ensures the agent is operating with the latest set of protocols." .

<file:///app/compliance/protocols/no-reset-all> proto:enforcement "This rule is enforced by the `master_control.py` orchestrator, which will immediately terminate the workflow with an error if an attempt is made to call this tool." ;
    schema:description "The `reset_all` tool is strictly forbidden under all circumstances. It is a legacy tool that has been superseded by more granular and safer methods of workspace management. Its use is considered a critical failure." .

<file:///app/compliance/protocols/non-compliance-architectural-deviation> proto:enforcement "Agent must revert non-compliant changes and re-implement them according to standards." ;
    schema:description "Forbids changes that contradict documented architectural patterns or coding conventions." .

<file:///app/compliance/protocols/non-compliance-definition> proto:enforcement "This is a definitional rule. Enforcement is achieved through the agent's adherence to the specific non-compliance rules that follow." ;
    schema:description "Defines non-compliance as a violation of any rule, convention, or procedure in AGENTS.md or its source protocols." .

<file:///app/compliance/protocols/non-compliance-direct-editing> proto:associatedTool <file:///app/compliance/protocols/restore_file>,
        <file:///app/compliance/protocols/run_in_bash_session> ;
    proto:enforcement "Agent must revert direct edits and modify source files, then run the appropriate build command." ;
    schema:description "Prohibits the direct editing of build artifacts like AGENTS.md or README.md. Changes must be made to source files, followed by a rebuild." .

<file:///app/compliance/protocols/non-compliance-self-awareness-failure> proto:associatedTool <file:///app/compliance/protocols/run_in_bash_session> ;
    proto:enforcement "Agent should run 'make AGENTS.md' to refresh its protocol knowledge and re-evaluate its plan." ;
    schema:description "Requires the agent to maintain an up-to-date understanding of protocols by recompiling AGENTS.md when necessary." .

<file:///app/compliance/protocols/non-compliance-test-procedure> proto:associatedTool <file:///app/compliance/protocols/run_in_bash_session> ;
    proto:enforcement "Agent must halt execution and run the required tests, debugging any failures before proceeding." ;
    schema:description "Requires adherence to all documented testing procedures before submitting changes." .

<file:///app/compliance/protocols/pre-commit-instructions-mandate> proto:enforcement "The agent's core logic should invoke this tool as the entry point to the pre-submission phase." ;
    schema:description "Before submitting changes, the agent MUST execute the `pre_commit_instructions` tool to receive the required sequence of validation steps (e.g., running tests, requesting code review)." .

<file:///app/compliance/protocols/verify-after-write> proto:enforcement "This is a core operational discipline. Future tooling, such as a trace validator, could enforce this by analyzing the execution log against this protocol." ;
    schema:description "After every file creation or modification action (`create_file_with_block`, `overwrite_file_with_block`, `replace_with_git_merge_diff`), the agent MUST use a subsequent read-only tool (`read_file`, `list_files`, `grep`) to verify that the action was executed successfully and had the intended effect. A plan step should only be marked as complete after this verification." .

<file:///app/core/protocols/aorp-identity> proto:enforcement "Protocol is identified by its name in documentation and compiled artifacts." ;
    schema:description "The governing protocol set is identified as the Advanced Orientation and Research Protocol (AORP)." .

<file:///app/core/protocols/aorp-mandate> proto:enforcement "Enforced by the agent's core operational loop and the `start` command in `tooling/fdc_cli.py`." ;
    schema:description "All Finite Development Cycles (FDCs) MUST be initiated using the FDC toolchain's 'start' command. This is non-negotiable." .

<file:///app/core/protocols/aorp-versioning> proto:enforcement "Build or validation scripts should verify the presence and format of the VERSION file." ;
    schema:description "The official protocol version is tracked in the VERSION file in the repository root, following Semantic Versioning (SemVer)." .

<file:///app/core/protocols/automated-orchestration> proto:enforcement "This script is the designated engine for the PDSC workflow." ;
    schema:description "The self-correction cycle must be managed by the `tooling/self_correction_orchestrator.py` script, which processes pending lessons and triggers the necessary updates." .

<file:///app/core/protocols/autonomous-code-suggestion> proto:enforcement "The `tooling/self_correction_orchestrator.py` invokes the code suggester when it processes a lesson of this type." ;
    schema:description "The self-correction system can generate and apply code changes to its own tooling. This is achieved through a `PROPOSE_CODE_CHANGE` action, which is processed by `tooling/code_suggester.py` to create an executable plan." .

<file:///app/core/protocols/bounded-recursion> proto:enforcement "The `lint` command in `tooling/fdc_cli.py` scans plans for disallowed recursive calls." ;
    schema:description "The agent MUST NOT generate plans that involve recursion or self-invocation. A plan cannot trigger another FDC or a sub-plan, with the sole exception of the 'Deep Research Cycle'." .

<file:///app/core/protocols/executable-plans> proto:enforcement "The output of the research planner must be linted and validated by the `fdc_cli.py` tool using the `research_fsm.json`." ;
    schema:description "Research plans must be generated by `tooling/research_planner.py` as valid, executable plans that conform to the `research_fsm.json` definition. They are not just templates but formal, verifiable artifacts." .

<file:///app/core/protocols/fdc-entry-point> proto:enforcement "Enforced by the `start` command in `tooling/fdc_cli.py`." ;
    schema:description "The AORP cascade is the mandatory entry point to every FDC." .

<file:///app/core/protocols/fdc-state-transitions> proto:enforcement "Validated by the `lint` command in `tooling/fdc_cli.py`." ;
    schema:description "The FDC is a Finite State Machine (FSM) formally defined in `tooling/fdc_fsm.json`. Plans must be valid strings in the language defined by this FSM." .

<file:///app/core/protocols/fdc-toolchain-mandate> proto:enforcement "The agent's internal logic is designed to prefer these specific tool commands for FDC state transitions." ;
    schema:description "Use the `fdc_cli.py` tool for all core FDC state transitions: task initiation ('start'), plan linting ('lint'), and task closure ('close')." .

<file:///app/core/protocols/fsm-adherence> proto:enforcement "The `lint` command in `tooling/fdc_cli.py` validates the plan against the FSM definition." ;
    schema:description "All plans must be valid strings in the language defined by the tooling/fdc_fsm.json Finite State Machine." .

<file:///app/core/protocols/hierarchical-planning-via-call-plan> proto:enforcement "The plan validator must be able to parse this directive and recursively validate sub-plans. The execution engine must implement a plan execution stack to manage the context of nested calls." ;
    schema:description "Plans may execute other plans as sub-routines using the 'call_plan <path_to_plan>' directive. This enables a modular, hierarchical workflow." .

<file:///app/core/protocols/l1-self-awareness> proto:enforcement "The `start` command of the FDC toolchain executes this step and fails if the artifact is missing or invalid." ;
    schema:description "Level 1 (Self-Awareness): The agent must first establish its own identity and inherent limitations by reading the `knowledge_core/agent_meta.json` artifact." .

<file:///app/core/protocols/l2-repository-sync> proto:enforcement "The `start` command of the FDC toolchain executes this step." ;
    schema:description "Level 2 (Repository Sync): The agent must understand the current state of the local repository by loading primary artifacts from the `knowledge_core/` directory." .

<file:///app/core/protocols/l3-environmental-probing> proto:enforcement "The `start` command of the FDC toolchain executes this step, utilizing tools like `google_search` and `view_text_website`." ;
    schema:description "Level 3 (Environmental Probing & Targeted RAG): The agent must discover the rules and constraints of its operational environment by executing a probe script and using targeted RAG to resolve 'known unknowns'." .

<file:///app/core/protocols/l4-deep-research-cycle> proto:enforcement "This is a special case of recursion, explicitly allowed and managed by the FDC toolchain." ;
    schema:description "Level 4 (Deep Research Cycle): To investigate 'unknown unknowns', the agent must initiate a formal, self-contained Finite Development Cycle (FDC) of the 'Analysis Modality'." .

<file:///app/core/protocols/l4-invocation> proto:enforcement "The `master_control.py` orchestrator is responsible for triggering the L4 cycle." ;
    schema:description "The L4 Deep Research Cycle is the designated mechanism for resolving complex 'unknown unknowns'. It is invoked by the main orchestrator when a task requires knowledge that cannot be obtained through simple L1-L3 orientation probes." .

<file:///app/core/protocols/mandate-research-tools> proto:enforcement "Adherence is monitored by the Code Review Critic and through post-mortem analysis of the activity log." ;
    schema:description "For all complex research tasks, the `plan_deep_research` tool MUST be used to generate a plan, and the `execute_research_protocol` tool MUST be used for data gathering. This ensures a systematic and auditable research process." .

<file:///app/core/protocols/mandatory-fdc-start> proto:enforcement "This is a hard-coded behavior in the agent's core operational loop and is verified by the FDC toolchain." ;
    schema:description "Upon receiving a new task, the agent's first action MUST be to programmatically execute the FDC 'start' command to formally initiate the task and run the AORP orientation cascade." .

<file:///app/core/protocols/max-recursion-depth> proto:enforcement "The execution engine must check the stack depth before every 'call_plan' execution and terminate with a fatal error if the limit would be exceeded." ;
    schema:description "To ensure decidability, the plan execution stack must not exceed a system-wide constant, MAX_RECURSION_DEPTH. This prevents infinite recursion and guarantees all processes will terminate." .

<file:///app/core/protocols/non-turing-completeness> proto:enforcement "Enforced by the design of the plan runner and validated by the `lint` command in the FDC toolchain." ;
    schema:description "The agent's planning and execution language is, by design, not Turing-complete. This is a fundamental constraint to guarantee that all processes will terminate." .

<file:///app/core/protocols/phase1-deconstruction> proto:enforcement "Procedural step guided by the agent's core logic, using artifacts in `logs/` and `knowledge_core/`." ;
    schema:description "Phase 1 (Deconstruction & Contextualization): The agent must ingest the task, query historical logs, identify entities using the symbol map, and analyze impact using the dependency graph." .

<file:///app/core/protocols/phase2-planning> proto:enforcement "The `lint` command in `tooling/fdc_cli.py` is a mandatory pre-flight check." ;
    schema:description "Phase 2 (Planning & Self-Correction): The agent must generate a granular plan, lint it using the FDC toolchain, cite evidence for its steps, and perform a critical review." .

<file:///app/core/protocols/phase3-execution> proto:enforcement "Logging is performed by the agent's action execution wrapper." ;
    schema:description "Phase 3 (Execution & Structured Logging): The agent must execute the validated plan and log every action according to the `LOGGING_SCHEMA.md`." .

<file:///app/core/protocols/phase4-post-mortem> proto:enforcement "The `close` command in `tooling/fdc_cli.py` initiates this phase." ;
    schema:description "Phase 4 (Pre-Submission Post-Mortem): The agent must formally close the task using the `close` command and complete the generated post-mortem report." .

<file:///app/core/protocols/programmatic-rule-refinement> proto:enforcement "The `tooling/knowledge_compiler.py` can generate `update-rule` actions, and the `tooling/self_correction_orchestrator.py` executes them." ;
    schema:description "The self-correction system can modify the description of existing protocol rules via the `update-rule` command in `tooling/protocol_updater.py`, allowing it to refine its own logic." .

<file:///app/core/protocols/programmatic-updates> proto:enforcement "Agent's core logic should be designed to use this tool for all protocol modifications." ;
    schema:description "All modifications to protocol source files must be performed programmatically via the `tooling/protocol_updater.py` tool to ensure consistency and prevent manual errors." .

<file:///app/core/protocols/rag-mandate> proto:enforcement "This is a core principle of the L3 orientation phase, utilizing tools like `google_search`." ;
    schema:description "For any task involving external technologies, Just-In-Time External RAG is REQUIRED to verify current best practices. Do not trust internal knowledge." .

<file:///app/core/protocols/registry-definition> proto:enforcement "The file's existence and format can be checked by the validation toolchain." ;
    schema:description "A central plan registry MUST exist at 'knowledge_core/plan_registry.json'. It maps logical plan names to their file paths." .

<file:///app/core/protocols/registry-first-resolution> proto:enforcement "This logic must be implemented in both the plan validator (`fdc_cli.py`) and the execution engine (`master_control.py`)." ;
    schema:description "The 'call_plan <argument>' directive MUST first attempt to resolve '<argument>' as a logical name in the plan registry. If resolution fails, it MUST fall back to treating '<argument>' as a direct file path for backward compatibility." .

<file:///app/core/protocols/registry-management-tool> proto:enforcement "The tool's existence and functionality can be verified via integration tests." ;
    schema:description "A dedicated tool (`tooling/plan_manager.py`) MUST be provided for managing the plan registry, with functions to register, deregister, and list plans." .

<file:///app/core/protocols/specialized-fsm> proto:enforcement "The `master_control.py` orchestrator must load and execute plans against this specific FSM when initiating an L4 Deep Research Cycle." ;
    schema:description "The Research FDC must be governed by its own dedicated Finite State Machine, defined in `tooling/research_fsm.json`. This FSM is tailored for a research workflow, with states for gathering, synthesis, and reporting." .

<file:///app/core/protocols/structured-lessons> proto:enforcement "The `tooling/knowledge_compiler.py` script is responsible for generating lessons in the correct format." ;
    schema:description "Lessons learned from post-mortem analysis must be generated as structured, machine-readable JSON objects in `knowledge_core/lessons.jsonl`." .

<file:///app/core/protocols/structured-research-phases> proto:enforcement "The plan's structure itself enforces this rule. The `lint` command can be extended to validate the structure of registered research plans." ;
    schema:description "The deep research plan MUST follow a structured four-phase process: Scoping, Broad Gathering, Targeted Extraction, and Synthesis." .

<file:///app/critic/protocols/built-in-tools-are-valid> proto:enforcement "The Code Review Critic must not flag a change as 'incomplete' or 'non-functional' solely because the implementation of a built-in tool is not present in the repository." ;
    schema:description "The agent's execution environment provides a set of built-in tools (e.g., `read_file`, `delete_file`, `pre_commit_instructions`). The implementation of these tools does not reside within the repository. A protocol change that adds a built-in tool to the `associated_tools` list is a valid and complete functional change." .

<file:///app/critic/protocols/critic-no-reset> proto:enforcement "This rule is enforced by its inclusion in the compiled AGENTS.md, which serves as the context for the Code Review Critic. The critic must be programmed to parse and adhere to this prohibition." ;
    schema:description "The agent role-playing as the 'Code Review Critic' is explicitly forbidden from invoking the 'reset_all' tool under any circumstances. This is a critical safeguard to prevent the loss of work during the review process." .

<file:///app/critic/protocols/functional-change-definition> proto:enforcement "The Code Review Critic's evaluation of 'functionality' must encompass both traditional code and protocol definitions." ;
    schema:description "A change is considered 'functional' if it correctly modifies the agent's operational rules or capabilities, as defined by the combination of Python source code and the protocol source files in `protocols/`." .

<file:///app/critic/protocols/protocol-as-source-code> proto:enforcement "The Code Review Critic must analyze changes in this directory with the same rigor as changes to `.py` files." ;
    schema:description "The `protocols/` directory and all its contents (`.md`, `.json` files) MUST be treated as functional source code. Changes to these files directly alter the agent's operational capabilities and governing rules." .

<file:///app/protocols/bootstrap-load-agents-md> proto:enforcement "This rule is enforced by the agent's core startup logic. The agent must verify the load of AGENTS.md before proceeding to the planning phase." ;
    schema:description "Upon initialization for any task, the agent's first and highest-priority action must be to locate, read, and parse the AGENTS.md file in the repository root. This ensures the agent is properly contextualized before any planning or execution begins." .

<file:///app/protocols/communication-tool-access> proto:enforcement "The agent's core logic should be designed to use this tool for all user-facing communication." ;
    schema:description "The agent is authorized to use the `message_user` tool to communicate with the user, providing updates and asking for clarification. This is essential for a collaborative workflow." .

<file:///app/protocols/create-prologue-file> proto:enforcement "This is a procedural rule. The agent must verify the existence of 'prologue.txt' before using 'create_file_with_block' or similar tools for other files." ;
    schema:description "Before creating any new file as part of a task, the agent MUST first create a file named 'prologue.txt' with the content 'This is a prologue file.' This rule serves as a test of the agent's ability to adapt its behavior to new, dynamically loaded protocols." .

<file:///app/protocols/dependency-install-on-start> proto:enforcement "The agent's core startup logic should be designed to execute `pip install -r requirements.txt` as one of its initial actions." ;
    schema:description "Upon starting a task, after loading AGENTS.md, the agent MUST install all required Python packages listed in the `requirements.txt` file. This ensures the environment is correctly configured before any other tools are executed." .

<file:///app/protocols/execute-aura-script> proto:enforcement "The tool is used by invoking it from the command line with the path to the Aura script as an argument." ;
    schema:description "The `aura_executor.py` tool should be used to execute .aura script files. This tool provides the bridge between the agent's master control loop and the Aura language interpreter." .

<file:///app/protocols/execute-plllu-script> proto:enforcement "The tool is used by invoking it from the command line with the path to the pLLLU script as an argument." ;
    schema:description "The `plllu_runner.py` tool should be used to execute .plllu script files. This tool provides the bridge between the agent's master control loop and the pLLLU language interpreter." .

<file:///app/protocols/formal-proposal-required> proto:enforcement "The initial plan for any speculative task must include a step to generate and save a proposal artifact." ;
    schema:description "A speculative task must begin with the creation of a formal proposal document, outlining the objective, rationale, and plan." .

<file:///app/protocols/idle-state-trigger> proto:enforcement "The agent's main control loop must verify an idle state before allowing the invocation of a speculative plan." ;
    schema:description "The agent may only initiate a speculative task when it has no active, user-assigned tasks." .

<file:///app/protocols/model-a-constraints> proto:enforcement "Enforced by the `fsm_model_a.json` FSM used by the `csdc_cli.py` tool." ;
    schema:description "Model A permits `define_set_of_names` but forbids `define_diagonalization_function`." .

<file:///app/protocols/model-b-constraints> proto:enforcement "Enforced by the `fsm_model_b.json` FSM used by the `csdc_cli.py` tool." ;
    schema:description "Model B permits `define_diagonalization_function` but forbids `define_set_of_names`." .

<file:///app/protocols/planning-tool-access> proto:enforcement "The agent's core logic should be designed to use this tool for all planning activities." ;
    schema:description "The agent is authorized to use the `set_plan` tool to create and update its execution plan. This is a foundational capability for task execution." .

<file:///app/protocols/prove-sequent> proto:enforcement "The tool is used by invoking it from the command line with the sequent to be proved as an argument." ;
    schema:description "The `hdl_prover.py` tool should be used to check the provability of a logical sequent. This tool acts as a wrapper for the underlying Lisp-based prover." .

<file:///app/protocols/resource-constraints> proto:enforcement "This is a system-level constraint that the agent orchestrator must enforce." ;
    schema:description "Speculative tasks must operate under defined resource limits." .

<file:///app/protocols/run-all-audits> proto:enforcement "The tool is invoked via the command line, typically through the `make audit` target." ;
    schema:description "The `auditor.py` script should be used to run comprehensive checks on the repository's health. It can be run with 'all' to check protocols, plans, and documentation completeness." .

<file:///app/protocols/security/no-public-disclosure> proto:enforcement "Violation of this rule may result in being banned from the project community." ;
    schema:description "Vulnerabilities MUST NOT be disclosed publicly until a patch is available and has been distributed." .

<file:///app/protocols/security/vuln-reporting-channel> proto:enforcement "This is a procedural rule. The designated contact is specified in the project's main SECURITY.md file." ;
    schema:description "All suspected security vulnerabilities MUST be reported privately to the designated security contact." .

<file:///app/protocols/shell-is-primary-entry-point> proto:enforcement "This is a procedural rule. The agent's operational framework should only expose the agent_shell.py as the means of starting a new task." ;
    schema:description "All agent tasks must be initiated through the `agent_shell.py` script. This script is the designated, API-driven entry point that ensures proper initialization of the MasterControlGraph FSM, centralized logging, and programmatic lifecycle management. Direct execution of other tools or scripts is forbidden for task initiation." .

<file:///app/protocols/speculative-logging> proto:enforcement "The agent's logging and file-creation tools should be context-aware and apply this tag when in a speculative mode." ;
    schema:description "All logs and artifacts generated during a speculative task must be tagged as 'speculative'." .

<file:///app/protocols/toolchain-audit-on-schema-change> proto:enforcement "This is a procedural rule for any agent developing the protocol system. Adherence can be partially checked by post-commit hooks or review processes that look for a tooling audit in any change that modifies the specified core files." ;
    schema:description "If a change is made to the core protocol schema (`protocol.schema.json`) or to the compilers that process it (`protocol_compiler.py`, `hierarchical_compiler.py`), a formal audit of the entire `tooling/` directory MUST be performed as a subsequent step. This audit should verify that all tools are compatible with the new protocol structure." .

<file:///app/protocols/update-index-before-submit> proto:enforcement "This is a procedural rule. The agent's pre-submission checklist should include a step to run 'python tooling/file_indexer.py build'." ;
    schema:description "Before submitting any changes that alter the file structure (create, delete, rename), the agent MUST rebuild the repository's file index. This ensures that tools relying on the index, such as the FDC validator, have an accurate view of the filesystem." .

<file:///app/protocols/use-csdc-cli> proto:enforcement "The tool is used by invoking it from the command line with the plan file, model, and complexity as arguments." ;
    schema:description "The `csdc_cli.py` tool must be used to validate plans under the CSDC. This tool enforces model-specific constraints (A or B) and complexity requirements (P or EXP)." .

<file:///app/protocols/use-doc-builder-for-all-docs> proto:enforcement "The tool is invoked via the command line, typically through the `make docs`, `make readme`, or `make pages` targets." ;
    schema:description "The `doc_builder.py` script is the single entry point for generating all user-facing documentation, including system-level docs, README files, and GitHub Pages. It should be called with the appropriate '--format' argument." .

<file:///app/protocols/user-review-gate> proto:enforcement "The agent is forbidden from using tools like 'submit' or 'merge' within a speculative context. It must use 'request_user_input' to present the results." ;
    schema:description "Final artifacts from a speculative task must be submitted for user review and cannot be merged directly." .

<file:///app/protocols/verify-capability-acquisition> proto:enforcement "The tool is used by invoking it from the command line with the path to the target test file." ;
    schema:description "The `capability_verifier.py` tool should be used to test the agent's ability to acquire a new capability defined by a failing test file. The tool orchestrates the failure, self-correction, and verification process." .
