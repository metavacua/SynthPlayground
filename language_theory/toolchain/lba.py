import argparse
import sys
from collections import deque
from .grammar import Grammar
from .classifier import Classifier

class LBASimulator:
    """
    A simulator for a Linear Bounded Automaton, designed to recognize
    languages generated by non-contracting Context-Sensitive Grammars.
    """
    def __init__(self, grammar):
        self.productions = grammar.productions
        self.start_symbol = grammar.start_symbol

    def recognize(self, input_string):
        """
        Attempts to recognize the input_string by generating all possible
        derivations from the start symbol in a breadth-first manner.
        """
        if not input_string:
            return False

        # The queue stores configurations (sentential forms) to explore.
        queue = deque([[self.start_symbol]])
        # Visited set to prevent cycles and redundant explorations.
        visited = {tuple([self.start_symbol])}

        max_len = len(input_string)

        while queue:
            current_config_list = queue.popleft()
            current_config_str = "".join(current_config_list)

            # If the current string matches the input, we succeed.
            if current_config_str == input_string:
                return True

            # Apply every possible production rule to the current configuration.
            for lhs, rhs in self.productions:
                lhs_str = "".join(lhs)
                rhs_list = list(rhs)

                # Find all occurrences of the LHS in the current string.
                for i in range(len(current_config_list) - len(lhs) + 1):
                    # Check for a match at position i
                    if current_config_list[i:i+len(lhs)] == list(lhs):

                        # Create the new configuration by replacing LHS with RHS
                        new_config_list = current_config_list[:i] + rhs_list + current_config_list[i+len(lhs):]

                        # The LBA constraint: tape cannot exceed the original input length.
                        if len("".join(new_config_list)) > max_len:
                            continue

                        new_config_tuple = tuple(new_config_list)
                        if new_config_tuple not in visited:
                            visited.add(new_config_tuple)
                            queue.append(list(new_config_tuple))

        return False

def main():
    parser = argparse.ArgumentParser(description="A Linear Bounded Automaton (LBA) simulator for CSGs.")
    parser.add_argument("grammar_file", help="Path to the context-sensitive grammar file.")
    parser.add_argument("input_string", help="The string to recognize.")
    args = parser.parse_args()

    try:
        grammar = Grammar(args.grammar_file)
        classifier = Classifier(grammar)
        classification = classifier.classify()

        print(f"--- LBA Simulation for: {args.grammar_file} ---")
        print(f"Grammar Classification: {classification}")

        if "CONTEXT-SENSITIVE" not in classification:
            print("\nWARNING: This grammar may not be context-sensitive. The LBA may not be the appropriate recognizer.")

        simulator = LBASimulator(grammar)

        print(f"Attempting to recognize string: '{args.input_string}'")

        if simulator.recognize(args.input_string):
            print(f"\nSUCCESS: String '{args.input_string}' is recognized by the LBA.")
        else:
            print(f"\nFAILURE: String '{args.input_string}' is NOT recognized by the LBA.")

        print("---------------------------------------------")

    except FileNotFoundError:
        print(f"Error: Grammar file not found at {args.grammar_file}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
