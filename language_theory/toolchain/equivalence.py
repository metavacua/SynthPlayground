import argparse
import sys
import importlib.util
import itertools

def check_equivalence(original_func, controller_func, input_ranges, fuel_factor=1.5):
    """
    Checks for bounded extensional equivalence between two functions.

    Args:
        original_func: The original Python function.
        controller_func: The refactored controller function.
        input_ranges: A dictionary mapping argument names to iterables of test values.
        fuel_factor: A multiplier for determining the fuel needed.

    Returns:
        A tuple (is_equivalent, mismatches), where mismatches is a list of
        inputs that caused a failure.
    """
    is_equivalent = True
    mismatches = []

    arg_names = list(input_ranges.keys())
    value_combinations = list(itertools.product(*input_ranges.values()))

    print(f"--- Running Bounded Equivalence Check ---")
    print(f"Testing {len(value_combinations)} input combinations...")

    for values in value_combinations:
        initial_args = dict(zip(arg_names, values))

        try:
            # Run the original function
            original_result = original_func(**initial_args)

            # Estimate required fuel. This is a heuristic.
            # For the counter example, the number of iterations is limit - x.
            # A more general heuristic might be based on the magnitude of inputs.
            # Here, we'll use the largest input value * fuel_factor.
            numeric_values = [v for v in values if isinstance(v, (int, float))]
            required_fuel = int(max(numeric_values) * fuel_factor) if numeric_values else 100

            # Run the refactored controller
            controller_result = controller_func(list(values), fuel=required_fuel)

            if original_result != controller_result:
                is_equivalent = False
                mismatch_info = {
                    'inputs': initial_args,
                    'original_output': original_result,
                    'refactored_output': controller_result
                }
                mismatches.append(mismatch_info)
                print(f"  - MISMATCH on input {initial_args}: Original={original_result}, Refactored={controller_result}")
            else:
                 print(f"  - OK on input {initial_args}: Output={original_result}")


        except Exception as e:
            is_equivalent = False
            mismatch_info = {
                'inputs': initial_args,
                'error': str(e)
            }
            mismatches.append(mismatch_info)
            print(f"  - ERROR on input {initial_args}: {e}")

    print("-----------------------------------------")
    return is_equivalent, mismatches

def main():
    # This CLI is a demonstration. A real implementation would need to
    # dynamically load the refactored code, perhaps from a string or temp file.

    # For this test, we will hardcode the functions from our example.
    from language_theory.unbounded_recursion import counter

    # The refactored code generated by `refactor.py` needs to be defined.
    # We use exec for this demonstration. In a real tool, this would be handled
    # more robustly (e.g., writing to a temp file and importing).
    refactored_code = """
def counter_total(fuel, limit, x):
    if x < limit:
        if fuel > 0:
            x = x + 1
            return counter_total(fuel - 1, limit, x)
        else:
            # We'll return a special value instead of raising an exception
            # to make comparison easier.
            return "FUEL_EXHAUSTED"
    else:
        return x

def counter_controller(initial_args, fuel=100):
    try:
        result = counter_total(fuel, *initial_args)
        return result
    except Exception:
        return "CONTROLLER_ERROR"
"""

    # Execute the refactored code to define the functions in the current scope
    exec_scope = {}
    exec(refactored_code, exec_scope)
    counter_controller_func = exec_scope['counter_controller']

    # Define the input ranges to test
    # We are testing the function: counter(limit, x)
    input_ranges = {
        'limit': range(5, 10),
        'x': range(3) # 0, 1, 2
    }

    is_equivalent, mismatches = check_equivalence(
        counter,
        counter_controller_func,
        input_ranges
    )

    if is_equivalent:
        print("\nSUCCESS: The functions are extensionally equivalent within the tested bounds.")
    else:
        print(f"\nFAILURE: Found {len(mismatches)} mismatch(es).")

if __name__ == "__main__":
    main()
