# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the unified protocol compiler.
# All changes to agent protocols must be made in the source files
# located in the `testing/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable YAML definitions embedded.
# ---

# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the unified protocol compiler.
# All changes to agent protocols must be made in the source files
# located in the `testing/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable YAML definitions embedded.
# ---

# Protocol: Core Testing Standards

This protocol establishes the core standards for all tests in the repository.

## The Problem: Inconsistent and Unreliable Tests

Without a clear set of standards, tests can become inconsistent, unreliable, and difficult to maintain. This can lead to a number of problems, including:
*   **False Positives and Negatives:** Poorly written tests can produce misleading results, making it difficult to determine the true state of the codebase.
*   **Difficult to Understand:** Inconsistent tests can be difficult to understand, making it harder for developers to debug and maintain them.
*   **Poor Test Coverage:** Without a clear set of standards, it's easy to miss critical areas of the codebase, resulting in poor test coverage.

## The Solution: A Common Set of Standards

This protocol establishes a common set of standards for all tests in the repository, ensuring that they are consistent, reliable, and easy to maintain.

**Rule `core-testing-file-naming`**: All test files must be placed in the `tests/` directory and follow the `test_*.py` naming convention.

**Rule `core-testing-test-naming`**: All test methods must start with the `test_` prefix.

**Rule `core-testing-test-structure`**: All tests must use the `unittest` framework and follow the Arrange-Act-Assert pattern.

**Rule `core-testing-mocking`**: The `unittest.mock` library should be used for mocking, and mocks should be as specific as possible.

**Rule `core-testing-assertions`**: The `self.assert*` methods from the `unittest.TestCase` class should be used for all assertions.

**Rule `core-testing-test-coverage`**: All code must have a minimum of 80% test coverage.

---

```yaml
protocol_id: core-testing-standards-001
description: A protocol to establish the core standards for all tests in the repository.
rules:
- rule_id: core-testing-file-naming
  description: All test files must be placed in the `tests/` directory and follow the `test_*.py` naming convention.
  enforcement: This is a procedural rule. The agent should verify that all new test files adhere to this naming convention.
  validation_command: "find tests -name 'test_*.py' -print0 | xargs -0 -n1 python3 -m unittest discover"
  tags:
  - testing
  - naming
- rule_id: core-testing-test-naming
  description: All test methods must start with the `test_` prefix.
  enforcement: This is a procedural rule. The agent should verify that all new test methods adhere to this naming convention.
  validation_command: "grep -r 'def test_' tests/"
  tags:
  - testing
  - naming
- rule_id: core-testing-test-structure
  description: All tests must use the `unittest` framework and follow the Arrange-Act-Assert pattern.
  enforcement: This is a procedural rule. The agent should verify that all new tests adhere to this structure.
  tags:
  - testing
  - structure
- rule_id: core-testing-mocking
  description: The `unittest.mock` library should be used for mocking, and mocks should be as specific as possible.
  enforcement: This is a procedural rule. The agent should verify that all new tests use the `unittest.mock` library for mocking.
  tags:
  - testing
  - mocking
- rule_id: core-testing-assertions
  description: The `self.assert*` methods from the `unittest.TestCase` class should be used for all assertions.
  enforcement: This is a procedural rule. The agent should verify that all new tests use the `self.assert*` methods for assertions.
  tags:
  - testing
  - assertions
- rule_id: core-testing-test-coverage
  description: All code must have a minimum of 80% test coverage.
  enforcement: The agent must verify that the test coverage is above 80%.
  validation_command: "python3 tooling/untested_code_detector.py --threshold 80"
  tags:
  - testing
  - coverage
associated_tools:
- tooling/run_tests.py
version: 1.0.0
'@context':
  rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs: http://www.w3.org/2000/01/rdf-schema#
  xsd: http://www.w3.org/2001/XMLSchema#
  schema: https://schema.org/
  dct: http://purl.org/dc/terms/
  proto: https://factory.ai/ns/protocol/
  protocol_id: '@id'
  name: schema:name
  description: schema:description
  version: schema:version
  scope: proto:scope
  agents: proto:agents
  files: proto:files
  rules: proto:hasRule
  rule_id: '@id'
  enforcement: proto:enforcement
  implementation: proto:implementation
  type: '@type'
  patterns: proto:hasPattern
  flags: proto:flags
  details: rdfs:comment
  associated_tools:
    '@id': proto:associatedTool
    '@type': '@id'

```


---


---

# Protocol: Test-Driven Development (TDD)

This protocol mandates the use of Test-Driven Development for all new code.

## The Problem: Untested Code

Writing code without first writing a test can lead to several problems:
*   **Bugs:** Code is more likely to have bugs if it's not tested from the start.
*   **Unclear Requirements:** Writing a test first forces you to think through the requirements and design of the code.
*   **Difficult to Refactor:** Code without tests is difficult to refactor safely, as there's no way to know if you've broken something.

## The Solution: Test First

This protocol requires that a test is written before any new code.

**Rule `tdd-writing-new-code`**: When writing any new function or class, a corresponding test must be written first. The test should fail before the new code is implemented, and pass after.

This ensures that:
1.  All new code is testable by design.
2.  The codebase maintains a high level of test coverage.
3.  The development process is more robust and less prone to regressions.

---

# Protocol: Comprehensive Testing

This protocol mandates a comprehensive testing strategy to ensure code quality and stability.

## The Problem: Inadequate Testing

Without a formal testing protocol, it's easy for bugs to slip through, for code quality to degrade, and for regressions to occur. This can lead to a fragile and unreliable system.

## The Solution: A Multi-Layered Testing Approach

This protocol requires a multi-layered testing approach, including unit, integration, and end-to-end tests.

**Rule `testing-protocol-001`**: Before any code is submitted, the following conditions must be met:
1.  **Unit Tests**: All new functions and classes must have corresponding unit tests.
2.  **Integration Tests**: All new modules must have integration tests that verify their interactions with other modules.
3.  **End-to-End Tests**: All new features must have end-to-end tests that verify their functionality from the user's perspective.
4.  **All Tests Pass**: All tests in the test suite must pass.


---

```yaml
protocol_id: test-driven-development-001
description: A protocol to enforce Test-Driven Development (TDD) practices.
rules:
- rule_id: tdd-writing-new-code
  description: When writing any new function or class, a corresponding test must be
    written first. The test should fail before the new code is implemented, and pass
    after.
  enforcement: This is a procedural rule. The agent should verify that a failing test
    is committed before the implementation is committed.
  validation_command: python3 tooling/validate_tdd.py
  tags:
  - testing
- rule_id: tdd-enforcement-tool
  description: A TDD enforcement tool must be used to ensure that all new code is
    developed using TDD.
  enforcement: The agent must verify that a TDD enforcement tool is configured in
    the repository.
  validation_command: ls .claude/tdd-guard/settings.json
  tags:
  - testing
  - tooling
associated_tools:
- tooling/test_runner.py
version: 1.0.0
'@context':
  rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs: http://www.w3.org/2000/01/rdf-schema#
  xsd: http://www.w3.org/2001/XMLSchema#
  schema: https://schema.org/
  dct: http://purl.org/dc/terms/
  proto: https://factory.ai/ns/protocol/
  protocol_id: '@id'
  name: schema:name
  description: schema:description
  version: schema:version
  scope: proto:scope
  agents: proto:agents
  files: proto:files
  rules: proto:hasRule
  rule_id: '@id'
  enforcement: proto:enforcement
  implementation: proto:implementation
  type: '@type'
  patterns: proto:hasPattern
  flags: proto:flags
  details: rdfs:comment
  associated_tools:
    '@id': proto:associatedTool
    '@type': '@id'

```


---

```yaml
protocol_id: testing-protocol-001
version: 1.0.0
description: A protocol for ensuring comprehensive testing of all new code.
rules:
- rule_id: comprehensive-testing
  description: All new code must be accompanied by unit, integration, and end-to-end
    tests, and all tests must pass before submission.
  enforcement: This is a procedural rule. The agent should verify that all tests pass
    before submitting any changes.
  tags:
  - testing
  validation_command: python3 tooling/test_runner.py
'@context':
  rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns#
  rdfs: http://www.w3.org/2000/01/rdf-schema#
  xsd: http://www.w3.org/2001/XMLSchema#
  schema: https://schema.org/
  dct: http://purl.org/dc/terms/
  proto: https://factory.ai/ns/protocol/
  protocol_id: '@id'
  name: schema:name
  description: schema:description
  version: schema:version
  scope: proto:scope
  agents: proto:agents
  files: proto:files
  rules: proto:hasRule
  rule_id: '@id'
  enforcement: proto:enforcement
  implementation: proto:implementation
  type: '@type'
  patterns: proto:hasPattern
  flags: proto:flags
  details: rdfs:comment
  associated_tools:
    '@id': proto:associatedTool
    '@type': '@id'

```


---
