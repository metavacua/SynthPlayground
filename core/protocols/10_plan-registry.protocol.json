{
  "protocol_id": "plan-registry-001",
  "description": "Defines a central registry for discovering and executing hierarchical plans by a logical name.\n\n**Associated Tool Documentation (`tooling/plan_manager.py`):**\n\n  \n  ### `/app/tooling/plan_manager.py`\n  Provides a command-line interface for managing the agent's Plan Registry.\n  \n  This script is the administrative tool for the Plan Registry, a key component\n  of the Context-Free Development Cycle (CFDC) that enables hierarchical and\n  modular planning. The registry, located at `knowledge_core/plan_registry.json`,\n  maps human-readable, logical names to the file paths of specific plans. This\n  decouples the `call_plan` directive from hardcoded file paths, making plans\n  more reusable and the system more robust.\n  \n  This CLI provides three essential functions:\n  - **register**: Associates a new logical name with a plan file path, adding it\n    to the central registry.\n  - **deregister**: Removes an existing logical name and its associated path from\n    the registry.\n  - **list**: Displays all current name-to-path mappings in the registry.\n  \n  By providing a simple, standardized interface for managing this library of\n  reusable plans, this tool improves the agent's ability to compose complex\n  workflows from smaller, validated sub-plans.\n  \n  **Public Functions:**\n  \n  - #### `def deregister_plan(name)`\n    > Removes a plan from the registry by its logical name.\n  \n  - #### `def get_registry()`\n    > Loads the plan registry from its JSON file.\n  \n  - #### `def list_plans()`\n    > Lists all currently registered plans.\n  \n  - #### `def main()`\n    > Main function to run the plan management CLI.\n  \n  - #### `def register_plan(name, path)`\n    > Registers a new plan by mapping a logical name to a file path.\n  \n  - #### `def save_registry(registry_data)`\n    > Saves the given data to the plan registry JSON file.\n\n\n**Associated Tool Documentation (`tooling/master_control.py`):**\n\n  \n  ### `/app/tooling/master_control.py`\n  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).\n  \n  This script, master_control.py, is the heart of the agent's operational loop.\n  It implements the CFDC, a hierarchical planning and execution model based on a\n  Pushdown Automaton. This allows the agent to execute complex tasks by calling\n  plans as sub-routines.\n  \n  Core Responsibilities:\n  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable\n    plans to call other plans via the `call_plan` directive. This allows for\n    modular, reusable, and complex task decomposition. A maximum recursion depth\n    is enforced to guarantee decidability.\n  - **Plan Validation:** Contains the in-memory plan validator. Before execution,\n    it parses a plan and simulates its execution against a Finite State Machine\n    (FSM) to ensure it complies with the agent's operational protocols.\n  - **\"Registry-First\" Plan Resolution:** When resolving a `call_plan` directive,\n    it first attempts to look up the plan by its logical name in the\n    `knowledge_core/plan_registry.json`. If not found, it falls back to treating\n    the argument as a direct file path.\n  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to\n    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)\n    to ensure predictable and auditable behavior.\n  \n  This module is designed as a library to be controlled by an external shell\n  (e.g., `agent_shell.py`), making its interaction purely programmatic.\n  \n  **Public Classes:**\n  \n  - #### `class MasterControlGraph`\n    > A Finite State Machine (FSM) that enforces the agent's protocol.\n    > This graph reads a state definition and orchestrates the agent's workflow,\n    > ensuring that all protocol steps are followed in the correct order.\n  \n    **Methods:**\n    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`\n    - ##### `def do_awaiting_result(self, agent_state, logger)`\n      > Checks for the result of the background research process.\n    - ##### `def do_debugging(self, agent_state, logger)`\n      > Handles the debugging state.\n    - ##### `def do_execution(self, agent_state, step_result, logger)`\n      > Processes the result of a step and advances the execution state.\n    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`\n      > Handles the finalization of the task, guiding the agent through\n      > the structured post-mortem process.\n    - ##### `def do_generating_code(self, agent_state, logger)`\n      > Handles the code generation state.\n    - ##### `def do_orientation(self, agent_state, logger, tools)`\n      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.\n    - ##### `def do_planning(self, agent_state, plan_content, logger)`\n      > Validates a given plan, parses it, and initializes the plan stack.\n    - ##### `def do_researching(self, agent_state, logger)`\n      > Launches the background research process.\n    - ##### `def do_running_tests(self, agent_state, logger)`\n      > Handles the test execution state.\n    - ##### `def get_current_step(self, agent_state)`\n      > Returns the current command to be executed by the agent, or None if execution is complete.\n    - ##### `def get_trigger(self, source_state, dest_state)`\n      > Finds a trigger in the FSM definition for a transition from a source\n      > to a destination state. This is a helper to avoid hardcoding trigger\n      > strings in the state handlers.\n    - ##### `def validate_plan_for_model(self, plan_content, model)`\n      > Validates a plan against a specific CSDC model using the LBAValidator.\n\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "registry-definition",
      "description": "A central plan registry MUST exist at 'knowledge_core/plan_registry.json'. It maps logical plan names to their file paths.",
      "enforcement": "The file's existence and format can be checked by the validation toolchain."
    },
    {
      "rule_id": "registry-first-resolution",
      "description": "The 'call_plan <argument>' directive MUST first attempt to resolve '<argument>' as a logical name in the plan registry. If resolution fails, it MUST fall back to treating '<argument>' as a direct file path for backward compatibility.",
      "enforcement": "This logic must be implemented in both the plan validator (`fdc_cli.py`) and the execution engine (`master_control.py`)."
    },
    {
      "rule_id": "registry-management-tool",
      "description": "A dedicated tool (`tooling/plan_manager.py`) MUST be provided for managing the plan registry, with functions to register, deregister, and list plans.",
      "enforcement": "The tool's existence and functionality can be verified via integration tests."
    }
  ],
  "associated_tools": [
    "tooling/plan_manager.py",
    "tooling/master_control.py",
    "tooling/fdc_cli.py"
  ]
}