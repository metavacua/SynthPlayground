{
  "protocol_id": "self-correction-protocol-001",
  "description": "Defines the automated, closed-loop workflow for protocol self-correction.\n\n**Associated Tool Documentation (`tooling/knowledge_compiler.py`):**\n\n  \n  ### `/app/tooling/knowledge_compiler.py`\n  Extracts structured lessons from post-mortem reports and compiles them into a\n  centralized, long-term knowledge base.\n  \n  This script is a core component of the agent's self-improvement feedback loop.\n  After a task is completed, a post-mortem report is generated that includes a\n  section for \"Corrective Actions & Lessons Learned.\" This script automates the\n  process of parsing that section to extract key insights.\n  \n  It identifies pairs of \"Lesson\" and \"Action\" statements and transforms them\n  into a standardized, machine-readable format. These formatted entries are then\n  appended to the `knowledge_core/lessons.jsonl` file, which serves as the\n  agent's persistent memory of what has worked, what has failed, and what can be\n  improved in future tasks.\n  \n  The script is executed via the command line, taking the path to a completed\n  post-mortem file as its primary argument.\n  \n  **Public Functions:**\n  \n  - #### `def extract_lessons_from_postmortem(postmortem_content)`\n    > Parses a post-mortem report to extract lessons learned.\n    > Handles multiple possible section headers and formats.\n  \n  - #### `def extract_metadata_from_postmortem(postmortem_content)`\n    > Parses a post-mortem report to extract metadata like Task ID and Date.\n  \n  - #### `def format_lesson_entry(metadata, lesson_data)`\n    > Formats an extracted lesson into a structured JSON object.\n  \n  - #### `def main()`\n  \n  - #### `def parse_action_to_command(action_text)`\n    > Parses a natural language action string into a machine-executable command.\n    > \n    > This is the core of translating insights into automated actions. It uses\n    > pattern matching to identify specific, supported commands.\n\n\n**Associated Tool Documentation (`tooling/protocol_updater.py`):**\n\n  \n  ### `/app/tooling/protocol_updater.py`\n  A command-line tool for programmatically updating protocol source files.\n  \n  This script provides the mechanism for the agent to perform self-correction\n  by modifying its own governing protocols based on structured, actionable\n  lessons. It is a key component of the Protocol-Driven Self-Correction (PDSC)\n  workflow.\n  \n  The tool operates on the .protocol.json files located in the `protocols/`\n  directory, performing targeted updates based on command-line arguments.\n  \n  **Public Functions:**\n  \n  - #### `def add_tool_to_protocol(protocol_id, tool_name, protocols_dir)`\n    > Adds a tool to the 'associated_tools' list of a specified protocol.\n  \n  - #### `def find_protocol_file(protocol_id, protocols_dir)`\n    > Recursively finds the protocol file path corresponding to a given protocol_id.\n  \n  - #### `def main()`\n    > Main function to parse arguments and call the appropriate handler.\n  \n  - #### `def update_rule_in_protocol(protocol_id, rule_id, new_description, protocols_dir)`\n    > Updates the description of a specific rule within a protocol.\n\n\n**Associated Tool Documentation (`tooling/self_correction_orchestrator.py`):**\n\n  \n  ### `/app/tooling/self_correction_orchestrator.py`\n  Orchestrates the Protocol-Driven Self-Correction (PDSC) workflow.\n  \n  This script is the engine of the automated feedback loop. It reads structured,\n  actionable lessons from `knowledge_core/lessons.jsonl` and uses the\n  `protocol_updater.py` tool to apply them to the source protocol files.\n  \n  **Public Functions:**\n  \n  - #### `def load_lessons()`\n    > Loads all lessons from the JSONL file.\n  \n  - #### `def main()`\n    > Main function to run the self-correction workflow.\n  \n  - #### `def process_lessons(lessons, protocols_dir)`\n    > Processes all pending lessons, applies them, and updates their status.\n    > Returns True if any changes were made, False otherwise.\n  \n  - #### `def run_command(command)`\n    > Runs a command and returns True on success, False on failure.\n  \n  - #### `def save_lessons(lessons)`\n    > Saves a list of lessons back to the JSONL file, overwriting it.\n\n\n**Associated Tool Documentation (`tooling/code_suggester.py`):**\n\n  \n  ### `/app/tooling/code_suggester.py`\n  Handles the generation and application of autonomous code change suggestions.\n  \n  This tool is a key component of the advanced self-correction loop. It is\n  designed to be invoked by the self-correction orchestrator when a lesson\n  contains a 'propose-code-change' action.\n  \n  For its initial implementation, this tool acts as a structured executor. It\n  takes a lesson where the 'details' field contains a fully-formed git-style\n  merge diff and applies it to the target file. It does this by generating a\n  temporary, single-step plan file and signaling its location for the master\n  controller to execute.\n  \n  This establishes the fundamental workflow for autonomous code modification,\n  decoupling the suggestion logic from the execution logic. Future iterations\n  can enhance this tool with more sophisticated code generation capabilities\n  (e.g., using an LLM to generate the diff from a natural language description)\n  without altering the core orchestration process.\n  \n  **Public Functions:**\n  \n  - #### `def generate_suggestion_plan(filepath, diff_content)`\n    > Generates a temporary, single-step plan file to apply a code change.\n    > \n    > Args:\n    >     filepath: The path to the file that needs to be modified.\n    >     diff_content: The git-style merge diff block to be applied.\n    > \n    > Returns:\n    >     The path to the generated temporary plan file.\n  \n  - #### `def main()`\n    > Main entry point for the code suggester tool.\n    > Parses arguments, generates a plan, and prints the plan's path to stdout.\n",
  "rules": [
    {
      "rule_id": "structured-lessons",
      "description": "Lessons learned from post-mortem analysis must be generated as structured, machine-readable JSON objects in `knowledge_core/lessons.jsonl`.",
      "enforcement": "The `tooling/knowledge_compiler.py` script is responsible for generating lessons in the correct format."
    },
    {
      "rule_id": "programmatic-updates",
      "description": "All modifications to protocol source files must be performed programmatically via the `tooling/protocol_updater.py` tool to ensure consistency and prevent manual errors.",
      "enforcement": "Agent's core logic should be designed to use this tool for all protocol modifications."
    },
    {
      "rule_id": "automated-orchestration",
      "description": "The self-correction cycle must be managed by the `tooling/self_correction_orchestrator.py` script, which processes pending lessons and triggers the necessary updates.",
      "enforcement": "This script is the designated engine for the PDSC workflow."
    },
    {
      "rule_id": "programmatic-rule-refinement",
      "description": "The self-correction system can modify the description of existing protocol rules via the `update-rule` command in `tooling/protocol_updater.py`, allowing it to refine its own logic.",
      "enforcement": "The `tooling/knowledge_compiler.py` can generate `update-rule` actions, and the `tooling/self_correction_orchestrator.py` executes them."
    },
    {
      "rule_id": "autonomous-code-suggestion",
      "description": "The self-correction system can generate and apply code changes to its own tooling. This is achieved through a `PROPOSE_CODE_CHANGE` action, which is processed by `tooling/code_suggester.py` to create an executable plan.",
      "enforcement": "The `tooling/self_correction_orchestrator.py` invokes the code suggester when it processes a lesson of this type."
    }
  ],
  "associated_tools": [
    "tooling/knowledge_compiler.py",
    "tooling/protocol_updater.py",
    "tooling/self_correction_orchestrator.py",
    "tooling/code_suggester.py",
    "initiate_memory_recording"
  ],
  "associated_artifacts": [
    "knowledge_core/lessons.jsonl"
  ]
}