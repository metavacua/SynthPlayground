{
  "protocol_id": "research-fdc-001",
  "description": "Defines the formal Finite Development Cycle (FDC) for conducting deep research.\n\n**Associated Tool Documentation (`tooling/master_control.py`):**\n\n  \n  ### `/app/tooling/master_control.py`\n  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).\n  \n  This script, master_control.py, is the heart of the agent's operational loop.\n  It implements the CFDC, a hierarchical planning and execution model based on a\n  Pushdown Automaton. This allows the agent to execute complex tasks by calling\n  plans as sub-routines.\n  \n  Core Responsibilities:\n  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable\n    plans to call other plans via the `call_plan` directive. This allows for\n    modular, reusable, and complex task decomposition. A maximum recursion depth\n    is enforced to guarantee decidability.\n  - **Plan Validation:** Contains the in-memory plan validator. Before execution,\n    it parses a plan and simulates its execution against a Finite State Machine\n    (FSM) to ensure it complies with the agent's operational protocols.\n  - **\"Registry-First\" Plan Resolution:** When resolving a `call_plan` directive,\n    it first attempts to look up the plan by its logical name in the\n    `knowledge_core/plan_registry.json`. If not found, it falls back to treating\n    the argument as a direct file path.\n  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to\n    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)\n    to ensure predictable and auditable behavior.\n  \n  This module is designed as a library to be controlled by an external shell\n  (e.g., `agent_shell.py`), making its interaction purely programmatic.\n  \n  **Public Classes:**\n  \n  - #### `class MasterControlGraph`\n    > A Finite State Machine (FSM) that enforces the agent's protocol.\n    > This graph reads a state definition and orchestrates the agent's workflow,\n    > ensuring that all protocol steps are followed in the correct order.\n  \n    **Methods:**\n    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`\n    - ##### `def do_awaiting_result(self, agent_state, logger)`\n      > Checks for the result of the background research process.\n    - ##### `def do_debugging(self, agent_state, logger)`\n      > Handles the debugging state.\n    - ##### `def do_execution(self, agent_state, step_result, logger)`\n      > Processes the result of a step and advances the execution state.\n    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`\n      > Handles the finalization of the task, guiding the agent through\n      > the structured post-mortem process.\n    - ##### `def do_generating_code(self, agent_state, logger)`\n      > Handles the code generation state.\n    - ##### `def do_orientation(self, agent_state, logger, tools)`\n      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.\n    - ##### `def do_planning(self, agent_state, plan_content, logger)`\n      > Validates a given plan, parses it, and initializes the plan stack.\n    - ##### `def do_researching(self, agent_state, logger)`\n      > Launches the background research process.\n    - ##### `def do_running_tests(self, agent_state, logger)`\n      > Handles the test execution state.\n    - ##### `def get_current_step(self, agent_state)`\n      > Returns the current command to be executed by the agent, or None if execution is complete.\n    - ##### `def get_trigger(self, source_state, dest_state)`\n      > Finds a trigger in the FSM definition for a transition from a source\n      > to a destination state. This is a helper to avoid hardcoding trigger\n      > strings in the state handlers.\n    - ##### `def validate_plan_for_model(self, plan_content, model)`\n      > Validates a plan against a specific CSDC model using the LBAValidator.\n\n\n**Associated Tool Documentation (`tooling/research_planner.py`):**\n\n  \n  ### `/app/tooling/research_planner.py`\n  This module is responsible for generating a formal, FSM-compliant research plan\n  for a given topic. The output is a string that can be executed by the agent's\n  master controller.\n  \n  **Public Functions:**\n  \n  - #### `def plan_deep_research(topic, research_id)`\n    > Generates a multi-step, FSM-compliant plan for conducting deep research\n    > using the official project templates.\n    > \n    > Args:\n    >     topic (str): The research topic.\n    >     research_id (str): A unique ID for this research task.\n    > \n    > Returns:\n    >     str: A string containing the executable plan.\n\n\n**Associated Tool Documentation (`tooling/research.py`):**\n\n  \n  ### `/app/tooling/research.py`\n  This module contains the logic for executing research tasks based on a set of\n  constraints. It acts as a dispatcher, calling the appropriate tool (e.g.,\n  read_file, google_search) based on the specified target and scope.\n  \n  **Public Functions:**\n  \n  - #### `def execute_research_protocol(constraints)`\n    > Executes a research task based on a provided constraints dictionary.\n    > \n    > Args:\n    >     constraints (dict): A dictionary specifying the research target,\n    >                         scope, and other parameters.\n    > \n    > Returns:\n    >     str: The result of the research action, or an error message.\n\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "specialized-fsm",
      "description": "The Research FDC must be governed by its own dedicated Finite State Machine, defined in `tooling/research_fsm.json`. This FSM is tailored for a research workflow, with states for gathering, synthesis, and reporting.",
      "enforcement": "The `master_control.py` orchestrator must load and execute plans against this specific FSM when initiating an L4 Deep Research Cycle."
    },
    {
      "rule_id": "executable-plans",
      "description": "Research plans must be generated by `tooling/research_planner.py` as valid, executable plans that conform to the `research_fsm.json` definition. They are not just templates but formal, verifiable artifacts.",
      "enforcement": "The output of the research planner must be linted and validated by the `fdc_cli.py` tool using the `research_fsm.json`."
    },
    {
      "rule_id": "l4-invocation",
      "description": "The L4 Deep Research Cycle is the designated mechanism for resolving complex 'unknown unknowns'. It is invoked by the main orchestrator when a task requires knowledge that cannot be obtained through simple L1-L3 orientation probes.",
      "enforcement": "The `master_control.py` orchestrator is responsible for triggering the L4 cycle."
    }
  ],
  "associated_tools": [
    "tooling/master_control.py",
    "tooling/research_planner.py",
    "tooling/research.py",
    "tooling/fdc_cli.py"
  ]
}