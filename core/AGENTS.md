# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# All changes to agent protocols must be made in the source files
# located in the `protocols/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable JSON definitions embedded.
# ---


# Jules Agent Protocol: The Hierarchical Development Cycle

**Version:** 4.0.0

---

---

## 1. The Core Problem: Ensuring Formally Verifiable Execution

To tackle complex tasks reliably, an agent's workflow must be formally structured and guaranteed to terminateâ€”it must be **decidable**. This is achieved through a hierarchical system composed of a high-level **Orchestrator** that manages the agent's overall state and a low-level **FDC Toolchain** that governs the validity of the agent's plans. This structure prevents the system from entering paradoxical, non-terminating loops.

---

---

## 2. The Solution: A Two-Layered FSM System

---

### Layer 1: The Orchestrator (`master_control.py` & `fsm.json`)

The Orchestrator is the master Finite State Machine (FSM) that guides the agent through its entire lifecycle, from orientation to submission. It is not directly controlled by the agent's plan but rather directs the agent's state based on the successful completion of each phase.

**Key States (defined in `tooling/fsm.json`):**
*   `ORIENTING`: The initial state where the agent gathers context.
*   `PLANNING`: The state where the Orchestrator waits for the agent to produce a `plan.txt`.
*   `EXECUTING`: The state where the Orchestrator oversees the step-by-step execution of the validated plan.
*   `POST_MORTEM`: The state for finalizing the task and recording learnings.
*   `AWAITING_SUBMISSION`: The final state before the code is submitted.

**The Orchestrator's Critical Role in Planning:**
During the `PLANNING` state, the Orchestrator's most important job is to validate the agent-generated `plan.txt`. It does this by calling the FDC Toolchain's `lint` command. **A plan that fails this check will halt the entire process, preventing the agent from entering an invalid state.**

---

### Layer 2: The FDC Toolchain (`fdc_cli.py` & `fdc_fsm.json`)

The FDC Toolchain is a set of utilities that the agent uses to structure its work and that the Orchestrator uses for validation. The toolchain is governed by its own FSM (`tooling/fdc_fsm.json`), which defines the legal sequence of commands *within a plan*.

#### **FDC Commands for Agent Use:**

**`start` - Task Initiation**
*   **Usage:** The first command the agent MUST issue upon receiving a task.
*   **Command:** `run_in_bash_session python3 tooling/fdc_cli.py start --task-id "your-task-id"`
*   **Function:** Logs the `TASK_START` event, formally beginning the development cycle.

**`lint` - Pre-Flight Plan Validation**
*   **Usage:** A command the agent can use to self-correct its own plan before finalizing it. The Orchestrator will *always* run this command on `plan.txt` as a mandatory check.
*   **Command:** `run_in_bash_session python3 tooling/fdc_cli.py lint <plan_file.txt>`
*   **Function:** Performs a comprehensive check against the low-level FSM:
    1.  **Closure Mandate:** Ensures the plan's final action is a call to the `close` command.
    2.  **FSM Validation:** Validates the sequence of agent tools against `tooling/fdc_fsm.json`.
    3.  **Semantic Validation:** Checks for errors like using a file before creating it.

**`close` - Task Closure**
*   **Usage:** The **last command** in any valid plan.
*   **Command:** `run_in_bash_session python3 tooling/fdc_cli.py close --task-id "your-task-id"`
*   **Function:** Logs `TASK_END`, generates a post-mortem template, and signals to the Orchestrator that plan execution is complete.
---

---

### STANDING ORDERS

1.  **Orchestrator is Sovereign:** The agent's lifecycle is governed by `master_control.py`. The agent's primary job is to provide a valid `plan.txt` when the Orchestrator enters the `PLANNING` state.
2.  **Toolchain is Law:** All plans must be valid according to the `fdc_cli.py lint` command. A valid plan is one that passes the Closure Mandate and is a valid string in the language defined by `fdc_fsm.json`.
3.  **Hierarchy is Structure:** The Orchestrator (`master_control.py`) validates the agent's plan using the FDC Toolchain (`fdc_cli.py`). This separation ensures a robust, verifiable, and decidable development process, preventing the system from executing paradoxical or non-terminating plans.

---

# Protocol: The Context-Free Development Cycle (CFDC)

This protocol marks a significant evolution from the Finite Development Cycle (FDC), introducing a hierarchical planning model that enables far greater complexity and modularity while preserving the system's core guarantee of decidability.

## From FSM to Pushdown Automaton

The FDC was based on a Finite State Machine (FSM), which provided a strict, linear sequence of operations. While robust, this model was fundamentally limited: it could not handle nested tasks or sub-routines, forcing all plans to be monolithic.

The CFDC upgrades our execution model to a **Pushdown Automaton**. This is achieved by introducing a **plan execution stack**, which allows the system to call other plans as sub-routines. This enables a powerful new paradigm: **Context-Free Development Cycles**.

## The `call_plan` Directive

The core of the CFDC is the new `call_plan` directive. This allows one plan to execute another, effectively creating a parent-child relationship between them.

- **Usage:** `call_plan <path_to_sub_plan.txt>`
- **Function:** When the execution engine encounters this directive, it:
    1.  Pushes the current plan's state (e.g., the current step number) onto the execution stack.
    2.  Begins executing the sub-plan specified in the path.
    3.  Once the sub-plan completes, it pops the parent plan's state from the stack and resumes its execution from where it left off.

## Ensuring Decidability: The Recursion Depth Limit

A system with unbounded recursion is not guaranteed to terminate. To prevent this, the CFDC introduces a non-negotiable, system-wide limit on the depth of the plan execution stack.

**Rule `max-recursion-depth`**: The execution engine MUST enforce a maximum recursion depth, defined by a `MAX_RECURSION_DEPTH` constant. If a `call_plan` directive would cause the stack depth to exceed this limit, the entire process MUST terminate with an error. This hard limit ensures that even with recursive or deeply nested plans, the system remains a **decidable**, non-Turing-complete process that is guaranteed to halt.

---

# Protocol: The Plan Registry

This protocol introduces a Plan Registry to create a more robust, modular, and discoverable system for hierarchical plans. It decouples the act of calling a plan from its physical file path, allowing plans to be referenced by a logical name.

## The Problem with Path-Based Calls

The initial implementation of the Context-Free Development Cycle (CFDC) relied on direct file paths (e.g., `call_plan path/to/plan.txt`). This is brittle:
- If a registered plan is moved or renamed, all plans that call it will break.
- It is difficult for an agent to discover and reuse existing, validated plans.

## The Solution: A Central Registry

The Plan Registry solves this by creating a single source of truth that maps logical, human-readable plan names to their corresponding file paths.

- **Location:** `knowledge_core/plan_registry.json`
- **Format:** A simple JSON object of key-value pairs:
  ```json
  {
    "logical-name-1": "path/to/plan_1.txt",
    "run-all-tests": "plans/common/run_tests.txt"
  }
  ```

## Updated `call_plan` Logic

The `call_plan` directive is now significantly more powerful. When executing `call_plan <argument>`, the system will follow a **registry-first** approach:

1.  **Registry Lookup:** The system will first treat `<argument>` as a logical name and look it up in `knowledge_core/plan_registry.json`.
2.  **Path Fallback:** If the name is not found in the registry, the system will fall back to treating `<argument>` as a direct file path. This ensures full backward compatibility with existing plans.

## Management

A new tool, `tooling/plan_manager.py`, will be introduced to manage the registry with simple commands like `register`, `deregister`, and `list`, making it easy to maintain the library of reusable plans.

---

# Protocol: The Closed-Loop Self-Correction Cycle

This protocol describes the automated workflow that enables the agent to programmatically improve its own governing protocols based on new knowledge. It transforms the ad-hoc, manual process of learning into a reliable, machine-driven feedback loop.

## The Problem: The Open Loop

Previously, "lessons learned" were compiled into a simple markdown file, `knowledge_core/lessons_learned.md`. While this captured knowledge, it was a dead end. There was no automated process to translate these text-based insights into actual changes to the protocol source files. This required manual intervention, creating a significant bottleneck and a high risk of protocols becoming stale.

## The Solution: A Protocol-Driven Self-Correction (PDSC) Workflow

The PDSC workflow closes the feedback loop by introducing a set of new tools and structured data formats that allow the agent to enact its own improvements.

**1. Structured, Actionable Lessons (`knowledge_core/lessons.jsonl`):**
- Post-mortem analysis now generates lessons as structured JSON objects, not free-form text.
- Each lesson includes a machine-readable `action` field, which contains a specific, executable command.

**2. The Protocol Updater (`tooling/protocol_updater.py`):**
- A new, dedicated tool for programmatically modifying the protocol source files (`*.protocol.json`).
- It accepts commands like `add-tool`, allowing for precise, automated changes to protocol definitions.

**3. The Orchestrator (`tooling/self_correction_orchestrator.py`):**
- This script is the engine of the cycle. It reads `lessons.jsonl`, identifies pending lessons, and uses the `protocol_updater.py` to execute the defined actions.
- After applying a lesson, it updates the lesson's status, creating a clear audit trail.
- It finishes by running `make AGENTS.md` to ensure the changes are compiled into the live protocol.

This new, automated cycleâ€”**Analyze -> Structure Lesson -> Execute Correction -> Re-compile Protocol**â€”is a fundamental step towards autonomous self-improvement.

---

# Protocol: Deep Research Cycle

This protocol defines a standardized, multi-step plan for conducting in-depth research on a complex topic. It is designed to be a reusable, callable plan that ensures a systematic and thorough investigation.

The cycle consists of five main phases:
1.  **Review Scanned Documents:** The agent first reviews the content of documents found in the repository during the initial scan. This provides immediate, project-specific context.
2.  **Initial Scoping & Keyword Generation:** Based on the initial topic and the information from scanned documents, the agent generates a set of search keywords.
3.  **Broad Information Gathering:** The agent uses the keywords to perform broad web searches and collect a list of relevant URLs.
4.  **Targeted Information Extraction:** The agent visits the most promising URLs to extract detailed information.
5.  **Synthesis & Summary:** The agent synthesizes the gathered information into a coherent summary, which is saved to a research report file.

This structured approach ensures that research is not ad-hoc but is instead a repeatable and verifiable process.

---

# Protocol: The Formal Research Cycle (L4)

This protocol establishes the L4 Deep Research Cycle, a specialized, self-contained Finite Development Cycle (FDC) designed for comprehensive knowledge acquisition. It elevates research from a simple tool-based action to a formal, verifiable process.

## The Problem: Ad-Hoc Research

Previously, research was an unstructured activity. The agent could use tools like `google_search` or `read_file`, but there was no formal process for planning, executing, and synthesizing complex research tasks. This made it difficult to tackle "unknown unknowns" in a reliable and auditable way.

## The Solution: A Dedicated Research FDC

The L4 Research Cycle solves this by introducing a new, specialized Finite State Machine (FSM) tailored specifically for research. When the main orchestrator (`master_control.py`) determines that a task requires deep knowledge, it initiates this cycle.

### Key Features:

1.  **Specialized FSM (`tooling/research_fsm.json`):** Unlike the generic development FSM, the research FSM has states that reflect a true research workflow: `GATHERING`, `SYNTHESIZING`, and `REPORTING`. This provides a more accurate model for the task.
2.  **Executable Plans:** The `tooling/research_planner.py` is upgraded to generate formal, executable plans that are validated against the new research FSM. These are no longer just templates but are verifiable artifacts that guide the agent through the research process.
3.  **Formal Invocation:** The L4 cycle is a first-class citizen in the agent's architecture. The main orchestrator can formally invoke it, execute the research plan, and then integrate the resulting knowledge back into its main task.

This new protocol provides a robust, reliable, and formally verifiable mechanism for the agent to explore complex topics, making it significantly more autonomous and capable.

---

```json
{
  "protocol_id": "aorp-header",
  "description": "Defines the identity and versioning of the Advanced Orientation and Research Protocol (AORP).",
  "rules": [
    {
      "rule_id": "aorp-identity",
      "description": "The governing protocol set is identified as the Advanced Orientation and Research Protocol (AORP).",
      "enforcement": "Protocol is identified by its name in documentation and compiled artifacts."
    },
    {
      "rule_id": "aorp-versioning",
      "description": "The official protocol version is tracked in the VERSION file in the repository root, following Semantic Versioning (SemVer).",
      "enforcement": "Build or validation scripts should verify the presence and format of the VERSION file."
    }
  ]
}
```


---

```json
{
  "protocol_id": "core-directive-001",
  "description": "The mandatory first action for any new task, ensuring a formal start to the Finite Development Cycle (FDC).\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "mandatory-fdc-start",
      "description": "Upon receiving a new task, the agent's first action MUST be to programmatically execute the FDC 'start' command to formally initiate the task and run the AORP orientation cascade.",
      "enforcement": "This is a hard-coded behavior in the agent's core operational loop and is verified by the FDC toolchain."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py"
  ]
}
```


---

```json
{
  "protocol_id": "decidability-constraints-001",
  "description": "Ensures all development processes are formally decidable and computationally tractable.\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "non-turing-completeness",
      "description": "The agent's planning and execution language is, by design, not Turing-complete. This is a fundamental constraint to guarantee that all processes will terminate.",
      "enforcement": "Enforced by the design of the plan runner and validated by the `lint` command in the FDC toolchain."
    },
    {
      "rule_id": "bounded-recursion",
      "description": "The agent MUST NOT generate plans that involve recursion or self-invocation. A plan cannot trigger another FDC or a sub-plan, with the sole exception of the 'Deep Research Cycle'.",
      "enforcement": "The `lint` command in `tooling/fdc_cli.py` scans plans for disallowed recursive calls."
    },
    {
      "rule_id": "fsm-adherence",
      "description": "All plans must be valid strings in the language defined by the tooling/fdc_fsm.json Finite State Machine.",
      "enforcement": "The `lint` command in `tooling/fdc_cli.py` validates the plan against the FSM definition."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py",
    "tooling/fdc_fsm.json"
  ]
}
```


---

```json
{
  "protocol_id": "orientation-cascade-001",
  "description": "Defines the mandatory, four-tiered orientation cascade that must be executed at the start of any task to establish a coherent model of the agent's identity, environment, and the world state.\n\n**Associated Tool Documentation (`tooling/environmental_probe.py`):**\n\n  \n  ### `/app/tooling/environmental_probe.py`\n  Performs a series of checks to assess the capabilities of the execution environment.\n  \n  This script is a critical diagnostic tool run at the beginning of a task to\n  ensure the agent understands its operational sandbox. It verifies fundamental\n  capabilities required for most software development tasks:\n  \n  1.  **Filesystem I/O:** Confirms that the agent can create, write to, read from,\n      and delete files. It also provides a basic latency measurement for these\n      operations.\n  2.  **Network Connectivity:** Checks for external network access by attempting to\n      connect to a highly-available public endpoint (google.com). This is crucial\n      for tasks requiring `git` operations, package downloads, or API calls.\n  3.  **Environment Variables:** Verifies that standard environment variables are\n      accessible, which is a prerequisite for many command-line tools.\n  \n  The script generates a human-readable report summarizing the results of these\n  probes, allowing the agent to quickly identify any environmental constraints\n  that might impact its ability to complete a task.\n  \n  **Public Functions:**\n  \n  - #### `def main()`\n    > Runs all environmental probes and prints a summary report.\n  \n  - #### `def probe_environment_variables()`\n    > Checks for the presence of a common environment variable.\n  \n  - #### `def probe_filesystem()`\n    > Tests file system write/read/delete capabilities and measures latency.\n  \n  - #### `def probe_network()`\n    > Tests network connectivity and measures latency to a reliable external endpoint.\n",
  "rules": [
    {
      "rule_id": "l1-self-awareness",
      "description": "Level 1 (Self-Awareness): The agent must first establish its own identity and inherent limitations by reading the `knowledge_core/agent_meta.json` artifact.",
      "enforcement": "The `start` command of the FDC toolchain executes this step and fails if the artifact is missing or invalid."
    },
    {
      "rule_id": "l2-repository-sync",
      "description": "Level 2 (Repository Sync): The agent must understand the current state of the local repository by loading primary artifacts from the `knowledge_core/` directory.",
      "enforcement": "The `start` command of the FDC toolchain executes this step."
    },
    {
      "rule_id": "l3-environmental-probing",
      "description": "Level 3 (Environmental Probing & Targeted RAG): The agent must discover the rules and constraints of its operational environment by executing a probe script and using targeted RAG to resolve 'known unknowns'.",
      "enforcement": "The `start` command of the FDC toolchain executes this step, utilizing tools like `google_search` and `view_text_website`."
    },
    {
      "rule_id": "l4-deep-research-cycle",
      "description": "Level 4 (Deep Research Cycle): To investigate 'unknown unknowns', the agent must initiate a formal, self-contained Finite Development Cycle (FDC) of the 'Analysis Modality'.",
      "enforcement": "This is a special case of recursion, explicitly allowed and managed by the FDC toolchain."
    }
  ],
  "associated_tools": [
    "tooling/environmental_probe.py",
    "google_search",
    "view_text_website"
  ]
}
```


---

```json
{
  "protocol_id": "fdc-protocol-001",
  "description": "Defines the Finite Development Cycle (FDC), a formally defined process for executing a single, coherent task.\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "fdc-entry-point",
      "description": "The AORP cascade is the mandatory entry point to every FDC.",
      "enforcement": "Enforced by the `start` command in `tooling/fdc_cli.py`."
    },
    {
      "rule_id": "fdc-state-transitions",
      "description": "The FDC is a Finite State Machine (FSM) formally defined in `tooling/fdc_fsm.json`. Plans must be valid strings in the language defined by this FSM.",
      "enforcement": "Validated by the `lint` command in `tooling/fdc_cli.py`."
    },
    {
      "rule_id": "phase1-deconstruction",
      "description": "Phase 1 (Deconstruction & Contextualization): The agent must ingest the task, query historical logs, identify entities using the symbol map, and analyze impact using the dependency graph.",
      "enforcement": "Procedural step guided by the agent's core logic, using artifacts in `logs/` and `knowledge_core/`."
    },
    {
      "rule_id": "phase2-planning",
      "description": "Phase 2 (Planning & Self-Correction): The agent must generate a granular plan, lint it using the FDC toolchain, cite evidence for its steps, and perform a critical review.",
      "enforcement": "The `lint` command in `tooling/fdc_cli.py` is a mandatory pre-flight check."
    },
    {
      "rule_id": "phase3-execution",
      "description": "Phase 3 (Execution & Structured Logging): The agent must execute the validated plan and log every action according to the `LOGGING_SCHEMA.md`.",
      "enforcement": "Logging is performed by the agent's action execution wrapper."
    },
    {
      "rule_id": "phase4-post-mortem",
      "description": "Phase 4 (Pre-Submission Post-Mortem): The agent must formally close the task using the `close` command and complete the generated post-mortem report.",
      "enforcement": "The `close` command in `tooling/fdc_cli.py` initiates this phase."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py",
    "tooling/fdc_fsm.json",
    "knowledge_core/symbols.json",
    "knowledge_core/dependency_graph.json",
    "LOGGING_SCHEMA.md",
    "set_plan",
    "message_user"
  ]
}
```


---

```json
{
  "protocol_id": "standing-orders-001",
  "description": "A set of non-negotiable, high-priority mandates that govern the agent's behavior across all tasks.\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "aorp-mandate",
      "description": "All Finite Development Cycles (FDCs) MUST be initiated using the FDC toolchain's 'start' command. This is non-negotiable.",
      "enforcement": "Enforced by the agent's core operational loop and the `start` command in `tooling/fdc_cli.py`."
    },
    {
      "rule_id": "rag-mandate",
      "description": "For any task involving external technologies, Just-In-Time External RAG is REQUIRED to verify current best practices. Do not trust internal knowledge.",
      "enforcement": "This is a core principle of the L3 orientation phase, utilizing tools like `google_search`."
    },
    {
      "rule_id": "fdc-toolchain-mandate",
      "description": "Use the `fdc_cli.py` tool for all core FDC state transitions: task initiation ('start'), plan linting ('lint'), and task closure ('close').",
      "enforcement": "The agent's internal logic is designed to prefer these specific tool commands for FDC state transitions."
    }
  ],
  "associated_tools": [
    "tooling/fdc_cli.py",
    "google_search",
    "view_text_website"
  ]
}
```


---

```json
{
  "protocol_id": "cfdc-protocol-001",
  "description": "Defines the Context-Free Development Cycle (CFDC), a hierarchical planning and execution model.\n\n**Associated Tool Documentation (`tooling/master_control.py`):**\n\n  \n  ### `/app/tooling/master_control.py`\n  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).\n  \n  This script, master_control.py, is the heart of the agent's operational loop.\n  It implements the CFDC, a hierarchical planning and execution model based on a\n  Pushdown Automaton. This allows the agent to execute complex tasks by calling\n  plans as sub-routines.\n  \n  Core Responsibilities:\n  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable\n    plans to call other plans via the `call_plan` directive. This allows for\n    modular, reusable, and complex task decomposition. A maximum recursion depth\n    is enforced to guarantee decidability.\n  - **Plan Validation:** Contains the in-memory plan validator. Before execution,\n    it parses a plan and simulates its execution against a Finite State Machine\n    (FSM) to ensure it complies with the agent's operational protocols.\n  - **\"Registry-First\" Plan Resolution:** When resolving a `call_plan` directive,\n    it first attempts to look up the plan by its logical name in the\n    `knowledge_core/plan_registry.json`. If not found, it falls back to treating\n    the argument as a direct file path.\n  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to\n    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)\n    to ensure predictable and auditable behavior.\n  \n  This module is designed as a library to be controlled by an external shell\n  (e.g., `agent_shell.py`), making its interaction purely programmatic.\n  \n  **Public Classes:**\n  \n  - #### `class MasterControlGraph`\n    > A Finite State Machine (FSM) that enforces the agent's protocol.\n    > This graph reads a state definition and orchestrates the agent's workflow,\n    > ensuring that all protocol steps are followed in the correct order.\n  \n    **Methods:**\n    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`\n    - ##### `def do_awaiting_result(self, agent_state, logger)`\n      > Checks for the result of the background research process.\n    - ##### `def do_debugging(self, agent_state, logger)`\n      > Handles the debugging state.\n    - ##### `def do_execution(self, agent_state, step_result, logger)`\n      > Processes the result of a step and advances the execution state.\n    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`\n      > Handles the finalization of the task, guiding the agent through\n      > the structured post-mortem process.\n    - ##### `def do_generating_code(self, agent_state, logger)`\n      > Handles the code generation state.\n    - ##### `def do_orientation(self, agent_state, logger, tools)`\n      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.\n    - ##### `def do_planning(self, agent_state, plan_content, logger)`\n      > Validates a given plan, parses it, and initializes the plan stack.\n    - ##### `def do_researching(self, agent_state, logger)`\n      > Launches the background research process.\n    - ##### `def do_running_tests(self, agent_state, logger)`\n      > Handles the test execution state.\n    - ##### `def get_current_step(self, agent_state)`\n      > Returns the current command to be executed by the agent, or None if execution is complete.\n    - ##### `def get_trigger(self, source_state, dest_state)`\n      > Finds a trigger in the FSM definition for a transition from a source\n      > to a destination state. This is a helper to avoid hardcoding trigger\n      > strings in the state handlers.\n    - ##### `def validate_plan_for_model(self, plan_content, model)`\n      > Validates a plan against a specific CSDC model using the LBAValidator.\n\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "hierarchical-planning-via-call-plan",
      "description": "Plans may execute other plans as sub-routines using the 'call_plan <path_to_plan>' directive. This enables a modular, hierarchical workflow.",
      "enforcement": "The plan validator must be able to parse this directive and recursively validate sub-plans. The execution engine must implement a plan execution stack to manage the context of nested calls."
    },
    {
      "rule_id": "max-recursion-depth",
      "description": "To ensure decidability, the plan execution stack must not exceed a system-wide constant, MAX_RECURSION_DEPTH. This prevents infinite recursion and guarantees all processes will terminate.",
      "enforcement": "The execution engine must check the stack depth before every 'call_plan' execution and terminate with a fatal error if the limit would be exceeded."
    }
  ],
  "associated_tools": [
    "tooling/master_control.py",
    "tooling/fdc_cli.py"
  ]
}
```


---

```json
{
  "protocol_id": "plan-registry-001",
  "description": "Defines a central registry for discovering and executing hierarchical plans by a logical name.\n\n**Associated Tool Documentation (`tooling/plan_manager.py`):**\n\n  \n  ### `/app/tooling/plan_manager.py`\n  Provides a command-line interface for managing the agent's Plan Registry.\n  \n  This script is the administrative tool for the Plan Registry, a key component\n  of the Context-Free Development Cycle (CFDC) that enables hierarchical and\n  modular planning. The registry, located at `knowledge_core/plan_registry.json`,\n  maps human-readable, logical names to the file paths of specific plans. This\n  decouples the `call_plan` directive from hardcoded file paths, making plans\n  more reusable and the system more robust.\n  \n  This CLI provides three essential functions:\n  - **register**: Associates a new logical name with a plan file path, adding it\n    to the central registry.\n  - **deregister**: Removes an existing logical name and its associated path from\n    the registry.\n  - **list**: Displays all current name-to-path mappings in the registry.\n  \n  By providing a simple, standardized interface for managing this library of\n  reusable plans, this tool improves the agent's ability to compose complex\n  workflows from smaller, validated sub-plans.\n  \n  **Public Functions:**\n  \n  - #### `def deregister_plan(name)`\n    > Removes a plan from the registry by its logical name.\n  \n  - #### `def get_registry()`\n    > Loads the plan registry from its JSON file.\n  \n  - #### `def list_plans()`\n    > Lists all currently registered plans.\n  \n  - #### `def main()`\n    > Main function to run the plan management CLI.\n  \n  - #### `def register_plan(name, path)`\n    > Registers a new plan by mapping a logical name to a file path.\n  \n  - #### `def save_registry(registry_data)`\n    > Saves the given data to the plan registry JSON file.\n\n\n**Associated Tool Documentation (`tooling/master_control.py`):**\n\n  \n  ### `/app/tooling/master_control.py`\n  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).\n  \n  This script, master_control.py, is the heart of the agent's operational loop.\n  It implements the CFDC, a hierarchical planning and execution model based on a\n  Pushdown Automaton. This allows the agent to execute complex tasks by calling\n  plans as sub-routines.\n  \n  Core Responsibilities:\n  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable\n    plans to call other plans via the `call_plan` directive. This allows for\n    modular, reusable, and complex task decomposition. A maximum recursion depth\n    is enforced to guarantee decidability.\n  - **Plan Validation:** Contains the in-memory plan validator. Before execution,\n    it parses a plan and simulates its execution against a Finite State Machine\n    (FSM) to ensure it complies with the agent's operational protocols.\n  - **\"Registry-First\" Plan Resolution:** When resolving a `call_plan` directive,\n    it first attempts to look up the plan by its logical name in the\n    `knowledge_core/plan_registry.json`. If not found, it falls back to treating\n    the argument as a direct file path.\n  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to\n    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)\n    to ensure predictable and auditable behavior.\n  \n  This module is designed as a library to be controlled by an external shell\n  (e.g., `agent_shell.py`), making its interaction purely programmatic.\n  \n  **Public Classes:**\n  \n  - #### `class MasterControlGraph`\n    > A Finite State Machine (FSM) that enforces the agent's protocol.\n    > This graph reads a state definition and orchestrates the agent's workflow,\n    > ensuring that all protocol steps are followed in the correct order.\n  \n    **Methods:**\n    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`\n    - ##### `def do_awaiting_result(self, agent_state, logger)`\n      > Checks for the result of the background research process.\n    - ##### `def do_debugging(self, agent_state, logger)`\n      > Handles the debugging state.\n    - ##### `def do_execution(self, agent_state, step_result, logger)`\n      > Processes the result of a step and advances the execution state.\n    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`\n      > Handles the finalization of the task, guiding the agent through\n      > the structured post-mortem process.\n    - ##### `def do_generating_code(self, agent_state, logger)`\n      > Handles the code generation state.\n    - ##### `def do_orientation(self, agent_state, logger, tools)`\n      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.\n    - ##### `def do_planning(self, agent_state, plan_content, logger)`\n      > Validates a given plan, parses it, and initializes the plan stack.\n    - ##### `def do_researching(self, agent_state, logger)`\n      > Launches the background research process.\n    - ##### `def do_running_tests(self, agent_state, logger)`\n      > Handles the test execution state.\n    - ##### `def get_current_step(self, agent_state)`\n      > Returns the current command to be executed by the agent, or None if execution is complete.\n    - ##### `def get_trigger(self, source_state, dest_state)`\n      > Finds a trigger in the FSM definition for a transition from a source\n      > to a destination state. This is a helper to avoid hardcoding trigger\n      > strings in the state handlers.\n    - ##### `def validate_plan_for_model(self, plan_content, model)`\n      > Validates a plan against a specific CSDC model using the LBAValidator.\n\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "registry-definition",
      "description": "A central plan registry MUST exist at 'knowledge_core/plan_registry.json'. It maps logical plan names to their file paths.",
      "enforcement": "The file's existence and format can be checked by the validation toolchain."
    },
    {
      "rule_id": "registry-first-resolution",
      "description": "The 'call_plan <argument>' directive MUST first attempt to resolve '<argument>' as a logical name in the plan registry. If resolution fails, it MUST fall back to treating '<argument>' as a direct file path for backward compatibility.",
      "enforcement": "This logic must be implemented in both the plan validator (`fdc_cli.py`) and the execution engine (`master_control.py`)."
    },
    {
      "rule_id": "registry-management-tool",
      "description": "A dedicated tool (`tooling/plan_manager.py`) MUST be provided for managing the plan registry, with functions to register, deregister, and list plans.",
      "enforcement": "The tool's existence and functionality can be verified via integration tests."
    }
  ],
  "associated_tools": [
    "tooling/plan_manager.py",
    "tooling/master_control.py",
    "tooling/fdc_cli.py"
  ]
}
```


---

```json
{
  "protocol_id": "self-correction-protocol-001",
  "description": "Defines the automated, closed-loop workflow for protocol self-correction.\n\n**Associated Tool Documentation (`tooling/knowledge_compiler.py`):**\n\n  \n  ### `/app/tooling/knowledge_compiler.py`\n  Extracts structured lessons from post-mortem reports and compiles them into a\n  centralized, long-term knowledge base.\n  \n  This script is a core component of the agent's self-improvement feedback loop.\n  After a task is completed, a post-mortem report is generated that includes a\n  section for \"Corrective Actions & Lessons Learned.\" This script automates the\n  process of parsing that section to extract key insights.\n  \n  It identifies pairs of \"Lesson\" and \"Action\" statements and transforms them\n  into a standardized, machine-readable format. These formatted entries are then\n  appended to the `knowledge_core/lessons.jsonl` file, which serves as the\n  agent's persistent memory of what has worked, what has failed, and what can be\n  improved in future tasks.\n  \n  The script is executed via the command line, taking the path to a completed\n  post-mortem file as its primary argument.\n  \n  **Public Functions:**\n  \n  - #### `def extract_lessons_from_postmortem(postmortem_content)`\n    > Parses a post-mortem report to extract lessons learned.\n    > Handles multiple possible section headers and formats.\n  \n  - #### `def extract_metadata_from_postmortem(postmortem_content)`\n    > Parses a post-mortem report to extract metadata like Task ID and Date.\n  \n  - #### `def format_lesson_entry(metadata, lesson_data)`\n    > Formats an extracted lesson into a structured JSON object.\n  \n  - #### `def main()`\n  \n  - #### `def parse_action_to_command(action_text)`\n    > Parses a natural language action string into a machine-executable command.\n    > \n    > This is the core of translating insights into automated actions. It uses\n    > pattern matching to identify specific, supported commands.\n\n\n**Associated Tool Documentation (`tooling/protocol_updater.py`):**\n\n  \n  ### `/app/tooling/protocol_updater.py`\n  A command-line tool for programmatically updating protocol source files.\n  \n  This script provides the mechanism for the agent to perform self-correction\n  by modifying its own governing protocols based on structured, actionable\n  lessons. It is a key component of the Protocol-Driven Self-Correction (PDSC)\n  workflow.\n  \n  The tool operates on the .protocol.json files located in the `protocols/`\n  directory, performing targeted updates based on command-line arguments.\n  \n  **Public Functions:**\n  \n  - #### `def add_tool_to_protocol(protocol_id, tool_name, protocols_dir)`\n    > Adds a tool to the 'associated_tools' list of a specified protocol.\n  \n  - #### `def find_protocol_file(protocol_id, protocols_dir)`\n    > Recursively finds the protocol file path corresponding to a given protocol_id.\n  \n  - #### `def main()`\n    > Main function to parse arguments and call the appropriate handler.\n  \n  - #### `def update_rule_in_protocol(protocol_id, rule_id, new_description, protocols_dir)`\n    > Updates the description of a specific rule within a protocol.\n\n\n**Associated Tool Documentation (`tooling/self_correction_orchestrator.py`):**\n\n  \n  ### `/app/tooling/self_correction_orchestrator.py`\n  Orchestrates the Protocol-Driven Self-Correction (PDSC) workflow.\n  \n  This script is the engine of the automated feedback loop. It reads structured,\n  actionable lessons from `knowledge_core/lessons.jsonl` and uses the\n  `protocol_updater.py` tool to apply them to the source protocol files.\n  \n  **Public Functions:**\n  \n  - #### `def load_lessons()`\n    > Loads all lessons from the JSONL file.\n  \n  - #### `def main()`\n    > Main function to run the self-correction workflow.\n  \n  - #### `def process_lessons(lessons, protocols_dir)`\n    > Processes all pending lessons, applies them, and updates their status.\n    > Returns True if any changes were made, False otherwise.\n  \n  - #### `def run_command(command)`\n    > Runs a command and returns True on success, False on failure.\n  \n  - #### `def save_lessons(lessons)`\n    > Saves a list of lessons back to the JSONL file, overwriting it.\n\n\n**Associated Tool Documentation (`tooling/code_suggester.py`):**\n\n  \n  ### `/app/tooling/code_suggester.py`\n  Handles the generation and application of autonomous code change suggestions.\n  \n  This tool is a key component of the advanced self-correction loop. It is\n  designed to be invoked by the self-correction orchestrator when a lesson\n  contains a 'propose-code-change' action.\n  \n  For its initial implementation, this tool acts as a structured executor. It\n  takes a lesson where the 'details' field contains a fully-formed git-style\n  merge diff and applies it to the target file. It does this by generating a\n  temporary, single-step plan file and signaling its location for the master\n  controller to execute.\n  \n  This establishes the fundamental workflow for autonomous code modification,\n  decoupling the suggestion logic from the execution logic. Future iterations\n  can enhance this tool with more sophisticated code generation capabilities\n  (e.g., using an LLM to generate the diff from a natural language description)\n  without altering the core orchestration process.\n  \n  **Public Functions:**\n  \n  - #### `def generate_suggestion_plan(filepath, diff_content)`\n    > Generates a temporary, single-step plan file to apply a code change.\n    > \n    > Args:\n    >     filepath: The path to the file that needs to be modified.\n    >     diff_content: The git-style merge diff block to be applied.\n    > \n    > Returns:\n    >     The path to the generated temporary plan file.\n  \n  - #### `def main()`\n    > Main entry point for the code suggester tool.\n    > Parses arguments, generates a plan, and prints the plan's path to stdout.\n",
  "rules": [
    {
      "rule_id": "structured-lessons",
      "description": "Lessons learned from post-mortem analysis must be generated as structured, machine-readable JSON objects in `knowledge_core/lessons.jsonl`.",
      "enforcement": "The `tooling/knowledge_compiler.py` script is responsible for generating lessons in the correct format."
    },
    {
      "rule_id": "programmatic-updates",
      "description": "All modifications to protocol source files must be performed programmatically via the `tooling/protocol_updater.py` tool to ensure consistency and prevent manual errors.",
      "enforcement": "Agent's core logic should be designed to use this tool for all protocol modifications."
    },
    {
      "rule_id": "automated-orchestration",
      "description": "The self-correction cycle must be managed by the `tooling/self_correction_orchestrator.py` script, which processes pending lessons and triggers the necessary updates.",
      "enforcement": "This script is the designated engine for the PDSC workflow."
    },
    {
      "rule_id": "programmatic-rule-refinement",
      "description": "The self-correction system can modify the description of existing protocol rules via the `update-rule` command in `tooling/protocol_updater.py`, allowing it to refine its own logic.",
      "enforcement": "The `tooling/knowledge_compiler.py` can generate `update-rule` actions, and the `tooling/self_correction_orchestrator.py` executes them."
    },
    {
      "rule_id": "autonomous-code-suggestion",
      "description": "The self-correction system can generate and apply code changes to its own tooling. This is achieved through a `PROPOSE_CODE_CHANGE` action, which is processed by `tooling/code_suggester.py` to create an executable plan.",
      "enforcement": "The `tooling/self_correction_orchestrator.py` invokes the code suggester when it processes a lesson of this type."
    }
  ],
  "associated_tools": [
    "tooling/knowledge_compiler.py",
    "tooling/protocol_updater.py",
    "tooling/self_correction_orchestrator.py",
    "tooling/code_suggester.py",
    "initiate_memory_recording"
  ],
  "associated_artifacts": [
    "knowledge_core/lessons.jsonl"
  ]
}
```


---

```json
{
  "protocol_id": "research-protocol-001",
  "description": "A protocol for conducting systematic research using the integrated research toolchain.",
  "rules": [
    {
      "rule_id": "mandate-research-tools",
      "description": "For all complex research tasks, the `plan_deep_research` tool MUST be used to generate a plan, and the `execute_research_protocol` tool MUST be used for data gathering. This ensures a systematic and auditable research process.",
      "enforcement": "Adherence is monitored by the Code Review Critic and through post-mortem analysis of the activity log."
    }
  ],
  "associated_tools": [
    "tooling.research_planner.plan_deep_research",
    "tooling.research.execute_research_protocol"
  ]
}
```


---

```json
{
  "protocol_id": "deep-research-cycle-001",
  "description": "A standardized, callable plan for conducting in-depth research on a complex topic.",
  "rules": [
    {
      "rule_id": "structured-research-phases",
      "description": "The deep research plan MUST follow a structured four-phase process: Scoping, Broad Gathering, Targeted Extraction, and Synthesis.",
      "enforcement": "The plan's structure itself enforces this rule. The `lint` command can be extended to validate the structure of registered research plans."
    }
  ],
  "associated_tools": [
    "google_search",
    "view_text_website",
    "create_file_with_block"
  ]
}
```


---

```json
{
  "protocol_id": "research-fdc-001",
  "description": "Defines the formal Finite Development Cycle (FDC) for conducting deep research.\n\n**Associated Tool Documentation (`tooling/master_control.py`):**\n\n  \n  ### `/app/tooling/master_control.py`\n  The master orchestrator for the agent's lifecycle, implementing the Context-Free Development Cycle (CFDC).\n  \n  This script, master_control.py, is the heart of the agent's operational loop.\n  It implements the CFDC, a hierarchical planning and execution model based on a\n  Pushdown Automaton. This allows the agent to execute complex tasks by calling\n  plans as sub-routines.\n  \n  Core Responsibilities:\n  - **Hierarchical Plan Execution:** Manages a plan execution stack to enable\n    plans to call other plans via the `call_plan` directive. This allows for\n    modular, reusable, and complex task decomposition. A maximum recursion depth\n    is enforced to guarantee decidability.\n  - **Plan Validation:** Contains the in-memory plan validator. Before execution,\n    it parses a plan and simulates its execution against a Finite State Machine\n    (FSM) to ensure it complies with the agent's operational protocols.\n  - **\"Registry-First\" Plan Resolution:** When resolving a `call_plan` directive,\n    it first attempts to look up the plan by its logical name in the\n    `knowledge_core/plan_registry.json`. If not found, it falls back to treating\n    the argument as a direct file path.\n  - **FSM-Governed Lifecycle:** The entire workflow, from orientation to\n    finalization, is governed by a strict FSM definition (e.g., `tooling/fsm.json`)\n    to ensure predictable and auditable behavior.\n  \n  This module is designed as a library to be controlled by an external shell\n  (e.g., `agent_shell.py`), making its interaction purely programmatic.\n  \n  **Public Classes:**\n  \n  - #### `class MasterControlGraph`\n    > A Finite State Machine (FSM) that enforces the agent's protocol.\n    > This graph reads a state definition and orchestrates the agent's workflow,\n    > ensuring that all protocol steps are followed in the correct order.\n  \n    **Methods:**\n    - ##### `def __init__(self, fsm_path='tooling/fsm.json')`\n    - ##### `def do_awaiting_result(self, agent_state, logger)`\n      > Checks for the result of the background research process.\n    - ##### `def do_debugging(self, agent_state, logger)`\n      > Handles the debugging state.\n    - ##### `def do_execution(self, agent_state, step_result, logger)`\n      > Processes the result of a step and advances the execution state.\n    - ##### `def do_finalizing(self, agent_state, analysis_content, logger)`\n      > Handles the finalization of the task, guiding the agent through\n      > the structured post-mortem process.\n    - ##### `def do_generating_code(self, agent_state, logger)`\n      > Handles the code generation state.\n    - ##### `def do_orientation(self, agent_state, logger, tools)`\n      > Executes orientation, including analyzing the last post-mortem and scanning the filesystem.\n    - ##### `def do_planning(self, agent_state, plan_content, logger)`\n      > Validates a given plan, parses it, and initializes the plan stack.\n    - ##### `def do_researching(self, agent_state, logger)`\n      > Launches the background research process.\n    - ##### `def do_running_tests(self, agent_state, logger)`\n      > Handles the test execution state.\n    - ##### `def get_current_step(self, agent_state)`\n      > Returns the current command to be executed by the agent, or None if execution is complete.\n    - ##### `def get_trigger(self, source_state, dest_state)`\n      > Finds a trigger in the FSM definition for a transition from a source\n      > to a destination state. This is a helper to avoid hardcoding trigger\n      > strings in the state handlers.\n    - ##### `def validate_plan_for_model(self, plan_content, model)`\n      > Validates a plan against a specific CSDC model using the LBAValidator.\n\n\n**Associated Tool Documentation (`tooling/research_planner.py`):**\n\n  \n  ### `/app/tooling/research_planner.py`\n  This module is responsible for generating a formal, FSM-compliant research plan\n  for a given topic. The output is a string that can be executed by the agent's\n  master controller.\n  \n  **Public Functions:**\n  \n  - #### `def plan_deep_research(topic, research_id)`\n    > Generates a multi-step, FSM-compliant plan for conducting deep research\n    > using the official project templates.\n    > \n    > Args:\n    >     topic (str): The research topic.\n    >     research_id (str): A unique ID for this research task.\n    > \n    > Returns:\n    >     str: A string containing the executable plan.\n\n\n**Associated Tool Documentation (`tooling/research.py`):**\n\n  \n  ### `/app/tooling/research.py`\n  This module contains the logic for executing research tasks based on a set of\n  constraints. It acts as a dispatcher, calling the appropriate tool (e.g.,\n  read_file, google_search) based on the specified target and scope.\n  \n  **Public Functions:**\n  \n  - #### `def execute_research_protocol(constraints)`\n    > Executes a research task based on a provided constraints dictionary.\n    > \n    > Args:\n    >     constraints (dict): A dictionary specifying the research target,\n    >                         scope, and other parameters.\n    > \n    > Returns:\n    >     str: The result of the research action, or an error message.\n\n\n**Associated Tool Documentation (`tooling/fdc_cli.py`):**\n\n  \n  ### `/app/tooling/fdc_cli.py`\n  This script provides a command-line interface (CLI) for managing the Finite\n  Development Cycle (FDC).\n  \n  The FDC is a structured workflow for agent-driven software development. This CLI\n  is the primary human interface for interacting with that cycle, providing\n  commands to:\n  - **start:** Initiates a new development task, triggering the \"Advanced\n    Orientation and Research Protocol\" (AORP) to ensure the agent is fully\n    contextualized.\n  - **close:** Formally concludes a task, creating a post-mortem template for\n    analysis and lesson-learning.\n  - **validate:** Checks a given plan file for both syntactic and semantic\n    correctness against the FDC's governing Finite State Machine (FSM). This\n    ensures that a plan is executable and will not violate protocol.\n  - **analyze:** Examines a plan to determine its computational complexity (e.g.,\n    Constant, Polynomial, Exponential) and its modality (Read-Only vs.\n    Read-Write), providing insight into the plan's potential impact.\n  \n  **Public Functions:**\n  \n  - #### `def analyze_plan(plan_filepath, return_results=False)`\n    > Analyzes a plan file to determine its complexity class and modality.\n  \n  - #### `def close_task(task_id)`\n    > Automates the closing of a Finite Development Cycle.\n  \n  - #### `def main()`\n  \n  - #### `def start_task(task_id)`\n    > Initiates the AORP cascade for a new task.\n  \n  - #### `def validate_plan(plan_filepath)`\n",
  "rules": [
    {
      "rule_id": "specialized-fsm",
      "description": "The Research FDC must be governed by its own dedicated Finite State Machine, defined in `tooling/research_fsm.json`. This FSM is tailored for a research workflow, with states for gathering, synthesis, and reporting.",
      "enforcement": "The `master_control.py` orchestrator must load and execute plans against this specific FSM when initiating an L4 Deep Research Cycle."
    },
    {
      "rule_id": "executable-plans",
      "description": "Research plans must be generated by `tooling/research_planner.py` as valid, executable plans that conform to the `research_fsm.json` definition. They are not just templates but formal, verifiable artifacts.",
      "enforcement": "The output of the research planner must be linted and validated by the `fdc_cli.py` tool using the `research_fsm.json`."
    },
    {
      "rule_id": "l4-invocation",
      "description": "The L4 Deep Research Cycle is the designated mechanism for resolving complex 'unknown unknowns'. It is invoked by the main orchestrator when a task requires knowledge that cannot be obtained through simple L1-L3 orientation probes.",
      "enforcement": "The `master_control.py` orchestrator is responsible for triggering the L4 cycle."
    }
  ],
  "associated_tools": [
    "tooling/master_control.py",
    "tooling/research_planner.py",
    "tooling/research.py",
    "tooling/fdc_cli.py"
  ]
}
```


---
