# ---
# DO NOT EDIT THIS FILE DIRECTLY.
# This file is programmatically generated by the `protocol_compiler.py` script.
# All changes to agent protocols must be made in the source files
# located in the `protocols/` directory.
#
# This file contains the compiled protocols in a human-readable Markdown format,
# with machine-readable JSON definitions embedded.
# ---


# Protocol: Agent Bootstrap

**Rule `bootstrap-load-agents-md`**: Upon initialization for any task, the agent's first and highest-priority action must be to locate, read, and parse the `AGENTS.md` file in the repository root.

**Rationale**: The `AGENTS.md` file contains the master operational protocols, including build instructions, testing procedures, architectural guidelines, and rules governing the agent's own behavior. Failing to consult this file first is a critical operational failure. This protocol ensures that the agent is properly contextualized before any planning or execution begins.

**Procedure**:
1.  On task start, immediately execute a `read_file('AGENTS.md')` operation.
2.  Parse the contents of `AGENTS.md` to load all rules and protocols into active memory.
3.  The plan for the user's request must be formulated *after* and *in accordance with* the protocols loaded from `AGENTS.md`.
4.  If `AGENTS.md` is not found, the agent should notify the user of a critical configuration error.

**Rule `bootstrap-scan-for-documents`**: After processing `AGENTS.md`, the agent should perform a scan of the repository for document files that could contain relevant information.

**Rationale**: Important project documentation, specifications, or other relevant information may be contained in various document formats. Proactively scanning for and processing these documents will provide the agent with a more complete context for the task at hand.

**Procedure**:
1.  The agent will perform a file listing to identify potential documents of interest (e.g., `.pdf`, `.md`, `.txt`).
2.  For each identified document, the agent will use the appropriate tool to read and summarize its contents. For PDF files, this will involve using a PDF reading library.
3.  The agent will incorporate the summarized information into its understanding of the project and use it to inform the planning process.

---

# Protocol: Dependency Management

This protocol establishes a formal process for managing Python dependencies to ensure a reliable and repeatable execution environment.

## The Problem: Environmental Brittleness

The agent's operating environment previously lacked a formal dependency declaration. This required manual, trial-and-error installation of necessary packages (`jsonschema`, `rdflib`, `requests`) upon encountering `ModuleNotFoundError` exceptions. This process is inefficient, error-prone, and makes the successful execution of tasks dependent on undocumented, ad-hoc environmental setup.

## The Solution: Formal Dependency Declaration and Installation

To solve this, two components are introduced:

1.  **`requirements.txt`:** A standard `requirements.txt` file is added to the repository root. This file serves as the single source of truth for all required Python packages.
2.  **A New Protocol Rule:** A new rule, `dependency-install-on-start`, is established. This rule mandates that upon starting any task, the agent's first action *after* reading `AGENTS.md` should be to install the dependencies listed in `requirements.txt` using `pip`.

This protocol transforms dependency management from an ad-hoc, reactive process into a proactive, automated, and verifiable step in the agent's workflow, significantly improving its robustness and reliability.

---

# Protocol: Agent Shell Entry Point

This protocol establishes the `agent_shell.py` script as the sole, official entry point for initiating any and all agent tasks.

## The Problem: Inconsistent Initialization

Prior to this protocol, there was no formally mandated entry point for the agent. This could lead to tasks being initiated through different scripts, potentially bypassing critical setup procedures like FSM initialization, logger configuration, and state management. This inconsistency makes the agent's behavior less predictable and harder to debug.

## The Solution: A Single, Enforced Entry Point

This protocol mandates the use of `tooling/agent_shell.py` for all task initiations.

**Rule `shell-is-primary-entry-point`**: All agent tasks must be initiated through the `agent_shell.py` script.

This ensures that every task begins within a controlled, programmatic environment where:
1.  The MasterControlGraph FSM is correctly instantiated and run.
2.  The centralized logger is initialized for comprehensive, structured logging.
3.  The agent's lifecycle is managed programmatically, not through fragile file-based signals.

By enforcing a single entry point, this protocol enhances the reliability, auditability, and robustness of the entire agent system.

---

# Meta-Protocol: Toolchain Review on Schema Change

This protocol establishes a critical feedback loop to ensure the agent's toolchain remains synchronized with the architecture of its governing protocols.

## The Problem: Protocol-Toolchain Desynchronization

A significant process gap was identified where a major architectural change to the protocol system (e.g., the introduction of a hierarchical `AGENTS.md` structure) did not automatically trigger a review of the tools that depend on that structure. The `protocol_auditor.py` tool, for instance, became partially obsolete as it was unaware of the new hierarchical model, leading to incomplete audits. This demonstrates that the agent's tools can become desynchronized from its own governing rules, creating a critical blind spot.

## The Solution: Mandated Toolchain Audit

This protocol closes that gap by introducing a new rule that explicitly links changes in the protocol system's architecture to a mandatory review of the toolchain.

**Rule `toolchain-audit-on-schema-change`**: If a change is made to the core protocol schema (`protocol.schema.json`) or to the compilers that process it (`protocol_compiler.py`, `hierarchical_compiler.py`), a formal audit of the entire `tooling/` directory **must** be performed as a subsequent step.

This ensures that any modification to the fundamental way protocols are defined or processed is immediately followed by a conscious verification that all dependent tools are still functioning correctly and are aware of the new structure. This transforms the previously manual and error-prone discovery process into a formal, required step of the development lifecycle.

---

# Protocol: The Context-Sensitive Development Cycle (CSDC)

This protocol introduces a new form of development cycle that is sensitive to the logical context in which it operates. It moves beyond the purely structural validation of the FDC and CFDC to incorporate constraints based on fundamental principles of logic and computability.

The CSDC is founded on the idea of exploring the trade-offs between expressive power and the risk of self-referential paradoxes. It achieves this by defining two mutually exclusive development models.

## Model A: The Introspective Model

- **Permits:** `define_set_of_names`
- **Forbids:** `define_diagonalization_function`

This model allows the system to have a complete map of its own language, enabling powerful introspection and metaprogramming. However, it explicitly forbids the diagonalization function, a common source of paradoxes in self-referential systems. This can be seen as a GÃ¶del-like approach.

## Model B: The Self-Referential Model

- **Permits:** `define_diagonalization_function`
- **Forbids:** `define_set_of_names`

This model allows the system to define and use the diagonalization function, enabling direct self-reference. However, it prevents the system from having a complete name-map of its own expressions, which is another way to avoid paradox (related to Tarski's undefinability theorem).

## Complexity Classes

Both models can be further constrained by computational complexity:
- **Polynomial (P):** For plans that are considered computationally tractable.
- **Exponential (EXP):** For plans that may require significantly more resources, allowing for more complex but potentially less efficient solutions.

## The `csdc_cli.py` Tool

The CSDC is enforced by the `tooling/csdc_cli.py` tool. This tool validates a plan against a specified model and complexity class, ensuring that all constraints are met before execution.

---

# Protocol: pLLLU Execution

This protocol establishes the `plllu_runner.py` script as the official entry point for executing pLLLU (`.plllu`) files.

## The Problem: Lack of a Standard Runner

The pLLLU language provides a powerful way to define complex logic, but without a standardized execution tool, there is no reliable way to integrate these files into the agent's workflow.

## The Solution: A Dedicated Runner

This protocol mandates the use of `tooling/plllu_runner.py` for all pLLLU file executions.

**Rule `plllu-runner-is-entry-point`**: All pLLLU files must be executed through the `plllu_runner.py` script.

This ensures that every pLLLU file is executed in a controlled, programmatic environment.

---

# Security Protocol

This document outlines the security policies and procedures for this project. It includes guidelines for handling sensitive data, reporting vulnerabilities, and maintaining a secure development environment. All contributors are expected to adhere to these protocols to ensure the integrity and safety of the project.

---

# Protocol: Speculative Execution

This protocol empowers the agent to engage in creative and exploratory tasks when it is otherwise idle. It provides a formal framework for the agent to generate novel ideas, plans, or artifacts that are not direct responses to a user request, but are instead products of its own "imagination" and analysis of the repository.

The goal is to enable proactive, creative problem-solving and self-improvement, allowing the agent to "dream" productively within safe and well-defined boundaries.

## Rules

- **`idle-state-trigger`**: The Speculative Execution Protocol can only be invoked when the agent has no active, user-assigned task. This ensures that speculative work never interferes with primary duties.
- **`formal-proposal-required`**: The first action in any speculative task must be the creation of a formal proposal document. This document must outline the objective, rationale, and a detailed plan for the task.
- **`resource-constraints`**: All speculative tasks must operate under predefined resource constraints (e.g., time limits, computational resources) to prevent runaway processes.
- **`user-review-gate`**: The final output or artifact of a speculative task cannot be integrated or submitted directly. It must be presented to the user for formal review and approval.
- **`speculative-logging`**: All logs, artifacts, and actions generated during a speculative task must be clearly tagged with a `speculative` flag to distinguish them from standard, user-directed work.

---

```json
{
  "protocol_id": "agent-bootstrap-001",
  "description": "A foundational protocol that dictates the agent's initial actions upon starting any task.",
  "rules": [
    {
      "rule_id": "bootstrap-load-agents-md",
      "description": "Upon initialization for any task, the agent's first and highest-priority action must be to locate, read, and parse the AGENTS.md file in the repository root. This ensures the agent is properly contextualized before any planning or execution begins.",
      "enforcement": "This rule is enforced by the agent's core startup logic. The agent must verify the load of AGENTS.md before proceeding to the planning phase."
    }
  ],
  "associated_tools": [
    "read_file"
  ]
}
```


---

```json
{
  "protocol_id": "dependency-management-001",
  "description": "A protocol for ensuring a reliable execution environment through formal dependency management.",
  "rules": [
    {
      "rule_id": "dependency-install-on-start",
      "description": "Upon starting a task, after loading AGENTS.md, the agent MUST install all required Python packages listed in the `requirements.txt` file. This ensures the environment is correctly configured before any other tools are executed.",
      "enforcement": "The agent's core startup logic should be designed to execute `pip install -r requirements.txt` as one of its initial actions."
    }
  ],
  "associated_tools": [
    "run_in_bash_session"
  ]
}
```


---

```json
{
  "protocol_id": "agent-shell-001",
  "description": "A protocol governing the use of the interactive agent shell as the primary entry point for all tasks.",
  "rules": [
    {
      "rule_id": "shell-is-primary-entry-point",
      "description": "All agent tasks must be initiated through the `agent_shell.py` script. This script is the designated, API-driven entry point that ensures proper initialization of the MasterControlGraph FSM, centralized logging, and programmatic lifecycle management. Direct execution of other tools or scripts is forbidden for task initiation.",
      "enforcement": "This is a procedural rule. The agent's operational framework should only expose the agent_shell.py as the means of starting a new task."
    }
  ],
  "associated_tools": [
    "tooling/agent_shell.py"
  ]
}
```


---

```json
{
  "protocol_id": "toolchain-review-on-schema-change-001",
  "description": "A meta-protocol to ensure the agent's toolchain remains synchronized with the architecture of its governing protocols.",
  "rules": [
    {
      "rule_id": "toolchain-audit-on-schema-change",
      "description": "If a change is made to the core protocol schema (`protocol.schema.json`) or to the compilers that process it (`protocol_compiler.py`, `hierarchical_compiler.py`), a formal audit of the entire `tooling/` directory MUST be performed as a subsequent step. This audit should verify that all tools are compatible with the new protocol structure.",
      "enforcement": "This is a procedural rule for any agent developing the protocol system. Adherence can be partially checked by post-commit hooks or review processes that look for a tooling audit in any change that modifies the specified core files."
    }
  ],
  "associated_tools": [
    "tooling/protocol_auditor.py",
    "tooling/protocol_compiler.py",
    "tooling/hierarchical_compiler.py"
  ]
}
```


---

```json
{
  "protocol_id": "unified-auditor-001",
  "description": "A protocol for the unified repository auditing tool, which combines multiple health and compliance checks into a single interface.",
  "rules": [
    {
      "rule_id": "run-all-audits",
      "description": "The `auditor.py` script should be used to run comprehensive checks on the repository's health. It can be run with 'all' to check protocols, plans, and documentation completeness.",
      "enforcement": "The tool is invoked via the command line, typically through the `make audit` target."
    }
  ],
  "associated_tools": [
    "tooling/auditor.py"
  ]
}
```


---

```json
{
  "protocol_id": "aura-execution-001",
  "description": "A protocol for executing Aura scripts, enabling a more expressive and powerful planning and automation language for the agent.",
  "rules": [
    {
      "rule_id": "execute-aura-script",
      "description": "The `aura_executor.py` tool should be used to execute .aura script files. This tool provides the bridge between the agent's master control loop and the Aura language interpreter.",
      "enforcement": "The tool is used by invoking it from the command line with the path to the Aura script as an argument."
    }
  ],
  "associated_tools": [
    "tooling/aura_executor.py"
  ]
}
```


---

```json
{
  "protocol_id": "capability-verification-001",
  "description": "A protocol for using the capability verifier tool to empirically test the agent's monotonic improvement.",
  "rules": [
    {
      "rule_id": "verify-capability-acquisition",
      "description": "The `capability_verifier.py` tool should be used to test the agent's ability to acquire a new capability defined by a failing test file. The tool orchestrates the failure, self-correction, and verification process.",
      "enforcement": "The tool is used by invoking it from the command line with the path to the target test file."
    }
  ],
  "associated_tools": [
    "tooling/capability_verifier.py"
  ]
}
```


---

```json
{
  "protocol_id": "csdc-001",
  "description": "A protocol for the Context-Sensitive Development Cycle (CSDC), which introduces development models based on logical constraints.",
  "rules": [
    {
      "rule_id": "use-csdc-cli",
      "description": "The `csdc_cli.py` tool must be used to validate plans under the CSDC. This tool enforces model-specific constraints (A or B) and complexity requirements (P or EXP).",
      "enforcement": "The tool is used by invoking it from the command line with the plan file, model, and complexity as arguments."
    },
    {
      "rule_id": "model-a-constraints",
      "description": "Model A permits `define_set_of_names` but forbids `define_diagonalization_function`.",
      "enforcement": "Enforced by the `fsm_model_a.json` FSM used by the `csdc_cli.py` tool."
    },
    {
      "rule_id": "model-b-constraints",
      "description": "Model B permits `define_diagonalization_function` but forbids `define_set_of_names`.",
      "enforcement": "Enforced by the `fsm_model_b.json` FSM used by the `csdc_cli.py` tool."
    }
  ],
  "associated_tools": [
    "tooling/csdc_cli.py"
  ]
}
```


---

```json
{
  "protocol_id": "unified-doc-builder-001",
  "description": "A protocol for the unified documentation builder, which generates various documentation artifacts from the repository's sources of truth.",
  "rules": [
    {
      "rule_id": "use-doc-builder-for-all-docs",
      "description": "The `doc_builder.py` script is the single entry point for generating all user-facing documentation, including system-level docs, README files, and GitHub Pages. It should be called with the appropriate '--format' argument.",
      "enforcement": "The tool is invoked via the command line, typically through the `make docs`, `make readme`, or `make pages` targets."
    }
  ],
  "associated_tools": [
    "tooling/doc_builder.py"
  ]
}
```


---

```json
{
  "protocol_id": "file-indexing-001",
  "description": "A protocol for maintaining an up-to-date file index to accelerate tool performance.",
  "rules": [
    {
      "rule_id": "update-index-before-submit",
      "description": "Before submitting any changes that alter the file structure (create, delete, rename), the agent MUST rebuild the repository's file index. This ensures that tools relying on the index, such as the FDC validator, have an accurate view of the filesystem.",
      "enforcement": "This is a procedural rule. The agent's pre-submission checklist should include a step to run 'python tooling/file_indexer.py build'."
    }
  ],
  "associated_tools": [
    "tooling/file_indexer.py"
  ]
}
```


---

```json
{
  "protocol_id": "hdl-proving-001",
  "description": "A protocol for interacting with the Hypersequent-calculus-based logic engine, allowing the agent to perform formal logical proofs.",
  "rules": [
    {
      "rule_id": "prove-sequent",
      "description": "The `hdl_prover.py` tool should be used to check the provability of a logical sequent. This tool acts as a wrapper for the underlying Lisp-based prover.",
      "enforcement": "The tool is used by invoking it from the command line with the sequent to be proved as an argument."
    }
  ],
  "associated_tools": [
    "tooling/hdl_prover.py"
  ]
}
```


---

```json
{
  "protocol_id": "agent-interaction-001",
  "description": "A protocol governing the agent's core interaction and planning tools.",
  "rules": [
    {
      "rule_id": "planning-tool-access",
      "description": "The agent is authorized to use the `set_plan` tool to create and update its execution plan. This is a foundational capability for task execution.",
      "enforcement": "The agent's core logic should be designed to use this tool for all planning activities."
    },
    {
      "rule_id": "communication-tool-access",
      "description": "The agent is authorized to use the `message_user` tool to communicate with the user, providing updates and asking for clarification. This is essential for a collaborative workflow.",
      "enforcement": "The agent's core logic should be designed to use this tool for all user-facing communication."
    },
    {
      "rule_id": "forbid-list-files-experiment",
      "description": "The agent is forbidden from using the `list_files` tool for this experiment.",
      "enforcement": "This is a hardcoded rule for the experimental protocol."
    }
  ],
  "associated_tools": [
    "set_plan",
    "message_user"
  ]
}
```


---

```json
{
  "protocol_id": "plllu-execution-001",
  "description": "A protocol for executing pLLLU scripts, enabling a more expressive and powerful planning and automation language for the agent.",
  "rules": [
    {
      "rule_id": "execute-plllu-script",
      "description": "The `plllu_runner.py` tool should be used to execute .plllu script files. This tool provides the bridge between the agent's master control loop and the pLLLU language interpreter.",
      "enforcement": "The tool is used by invoking it from the command line with the path to the pLLLU script as an argument."
    }
  ],
  "associated_tools": [
    "tooling/plllu_runner.py"
  ]
}
```


---

```json
{
  "protocol_id": "security-header",
  "description": "Defines the identity and purpose of the Security Protocol document.",
  "rules": []
}
```


---

```json
{
  "protocol_id": "security-vuln-reporting-001",
  "description": "Defines the official policy and procedure for reporting security vulnerabilities.",
  "rules": [
    {
      "rule_id": "vuln-reporting-channel",
      "description": "All suspected security vulnerabilities MUST be reported privately to the designated security contact.",
      "enforcement": "This is a procedural rule. The designated contact is specified in the project's main SECURITY.md file."
    },
    {
      "rule_id": "no-public-disclosure",
      "description": "Vulnerabilities MUST NOT be disclosed publicly until a patch is available and has been distributed.",
      "enforcement": "Violation of this rule may result in being banned from the project community."
    }
  ]
}
```


---

```json
{
  "protocol_id": "speculative-execution-001",
  "description": "A protocol that governs the agent's ability to initiate and execute self-generated, creative, or exploratory tasks during idle periods.",
  "rules": [
    {
      "rule_id": "idle-state-trigger",
      "description": "The agent may only initiate a speculative task when it has no active, user-assigned tasks.",
      "enforcement": "The agent's main control loop must verify an idle state before allowing the invocation of a speculative plan."
    },
    {
      "rule_id": "formal-proposal-required",
      "description": "A speculative task must begin with the creation of a formal proposal document, outlining the objective, rationale, and plan.",
      "enforcement": "The initial plan for any speculative task must include a step to generate and save a proposal artifact."
    },
    {
      "rule_id": "resource-constraints",
      "description": "Speculative tasks must operate under defined resource limits.",
      "enforcement": "This is a system-level constraint that the agent orchestrator must enforce."
    },
    {
      "rule_id": "user-review-gate",
      "description": "Final artifacts from a speculative task must be submitted for user review and cannot be merged directly.",
      "enforcement": "The agent is forbidden from using tools like 'submit' or 'merge' within a speculative context. It must use 'request_user_input' to present the results."
    },
    {
      "rule_id": "speculative-logging",
      "description": "All logs and artifacts generated during a speculative task must be tagged as 'speculative'.",
      "enforcement": "The agent's logging and file-creation tools should be context-aware and apply this tag when in a speculative mode."
    }
  ],
  "associated_tools": [
    "set_plan",
    "create_file_with_block",
    "request_user_input"
  ]
}
```


---
